(define (/foreach-substitute_and_delete-1
         //depth
         //a/s_/type)
  (cond ((and (= (@st (@i)) //t_/call)
              (equal? (@v (@i)) //n))
         (@splice_over //s))))

(define (/foreach-substitute_and_delete-2
         //depth
         //a/s_/type)
  (cond ((@cs? (@i)) (@paste_over (@simplify_expn (@i))))))

(define (@substitute_and_delete_test)
  (let ((//n-save //n))
    (set! //n '())
    (cond ((= (@st (@i)) //t_/action)
           (set! //n (@v (list-ref (@i) (+ 1 1))))
           (cond ((equal? (@v (list-ref (@gparent) (+ 1 1))) //n)
                  (@fail "It is invalid to delete the starting action."))
                 (#t
                  (cond ((@called? //n (@i))
                         (@fail "The action is recursive."))
                        (#t (@pass))))))
          ((= (@st (@i)) //t_/proc)
           (set! //n (@v (list-ref (@i) (+ 1 1))))
           (cond ((@proc_called? //n (@i))
                  (@fail "Procedure is recursive"))
                 (#t (@pass))))
          ((= (@st (@i)) //t_/funct)
           (set! //n (@v (list-ref (@i) (+ 1 1))))
           (cond ((@funct_called? //n (@i))
                  (@fail "Function is recursive"))
                 ((or (> (@size (list-ref (@i) (+ 1 4))) 1)
                      (not (= (@st (list-ref (list-ref (@i) (+ 1 4)) (+ 1 1)))
                              //t_/skip)))
                  (@fail "Function definition includes statements"))
                 (#t (@pass))))
          (#t
           (@fail "Not an action, function or proc definition")))
    (@goto //orig_/pos)
    (set! //n //n-save)))

(define (@substitute_and_delete_code //data)
  (let ((//orig_/pos-save //orig_/pos)
        (//n-save //n)
        (//s-save //s))
    (set! //orig_/pos (@posn_n))
    (set! //n (@v (list-ref (@i) (+ 1 1))))
    (set! //s '())
    (cond ((= (@st (@i)) //t_/action)
           (set! //s (@cs (list-ref (@i) (+ 1 2))))
           (@up)
           (@foreach_statement
             /foreach-substitute_and_delete-1
             0
             (@as_type)
             0)
           (cond ((null? (@program)) (@new_program (@skips))))
           (@down_to //orig_/pos)
           (@clever_delete))
          ((= (@st (@i)) //t_/proc)
           (@up)
           (@up)
           (@edit)
           (@expand_proc_calls //n)
           (@end_edit)
           (@down_last)
           (@down_to //orig_/pos)
           (@clever_delete))
          ((= (@st (@i)) //t_/funct)
           (@up)
           (@up)
           (@edit)
           (@expand_funct_calls //n)
           (@end_edit)
           (@foreach_expn
             /foreach-substitute_and_delete-2
             0
             (@as_type)
             0)
           (cond ((null? (@program)) (@new_program (@skips))))
           (@down_last)
           (@down_to //orig_/pos)
           (@clever_delete)))
    (set! //orig_/pos //orig_/pos-save)
    (set! //n //n-save)
    (set! //s //s-save)))

(define (@expand_proc_calls //n-par)
  (let ((//n-save //n))
    (set! //n //n-par)
    (cond ((and (= (@st (@i)) //t_/proc_/call)
                (equal? (@v (list-ref (@i) (+ 1 1))) //n))
           (@trans //t/r_/expand_/call ""))
          ((and (@cs? (@i))
                (@has_statements_type? (@gt (@i))))
           (@down)
           (set! /fl_flag1 0)
           (let while-loop ()
             (cond ((= /fl_flag1 0)
                    (begin
                      (let ((//o/k 1))
                        (cond ((= (@st (@i)) //t_/where)
                               (@down_last)
                               (@down)
                               (let while-loop ()
                                 (cond ((and (not (equal?
                                                    (@v (list-ref (@i) (+ 1 1)))
                                                    //n))
                                             (@right?))
                                        (@right)
                                        (while-loop))
                                       (#t #t)))
                               (cond ((equal? (@v (list-ref (@i) (+ 1 1))) //n)
                                      (set! //o/k 0)))
                               (@up)
                               (@up)))
                        (cond ((= //o/k 1) (@expand_proc_calls //n))))
                      (cond ((not (@right?)) (set! /fl_flag1 1))
                            (#t (@right) (set! /fl_flag1 0))))
                    (while-loop))
                   (#t #t)))
           (@up)))
    (set! //n //n-save)))

(define (@expand_funct_calls //n-par)
  (let ((//n-save //n))
    (set! //n //n-par)
    (cond ((and (= (@st (@i)) //t_/funct_/call)
                (equal? (@v (list-ref (@i) (+ 1 1))) //n))
           (@trans //t/r_/expand_/call "")))
    (cond ((@cs? (@i))
           (@down)
           (set! /fl_flag1 0)
           (let while-loop ()
             (cond ((= /fl_flag1 0)
                    (begin
                      (let ((//o/k 1))
                        (cond ((= (@st (@i)) //t_/where)
                               (@down_last)
                               (@down)
                               (let while-loop ()
                                 (cond ((and (not (equal?
                                                    (@v (list-ref (@i) (+ 1 1)))
                                                    //n))
                                             (@right?))
                                        (@right)
                                        (while-loop))
                                       (#t #t)))
                               (cond ((equal? (@v (list-ref (@i) (+ 1 1))) //n)
                                      (set! //o/k 0)))
                               (@up)
                               (@up)))
                        (cond ((= //o/k 1) (@expand_funct_calls //n))))
                      (cond ((not (@right?)) (set! /fl_flag1 1))
                            (#t (@right) (set! /fl_flag1 0))))
                    (while-loop))
                   (#t #t)))
           (@up)))
    (set! //n //n-save)))

#t

