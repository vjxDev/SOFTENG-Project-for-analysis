(define (@merge_right_test)
  (cond ((and (= (@gen_type (@item)) //t_/assign)
              (@up?)
              (not (@left?))
              (not (@right?)))
         (@up)))
  (cond ((not (= (@gen_type (@item)) //t_/statement))
         (@fail "The selected item is not a Statement."))
        ((not (@right?))
         (@fail "There is no statement to the Right of this one."))
        (#t
         (@right)
         (cond ((@trans? //t/r_/absorb_/left) (@pass))
               ((= (@spec_type (@item)) //t_/assignment)
                (let ((//a (@assigned (@item))) (//u (@used (@item))))
                  (@left)
                  (cond ((and (= (@spec_type (@item)) //t_/assignment)
                              (null? (@set_intersect //a (@variables (@item))))
                              (null? (@set_intersect //u (@assigned (@item)))))
                         (@pass))
                        (#t
                         (@fail "The assignments were too complex (for this version).")))))
               (#t
                (@fail "It was not possible to `Absorb Left' on the previous statement."))))))

(define (@merge_right_code //data)
  (cond ((and (= (@gen_type (@item)) //t_/assign)
              (@up?)
              (not (@left?))
              (not (@right?)))
         (@up)))
  (@right)
  (cond ((@trans? //t/r_/absorb_/left)
         (@trans //t/r_/absorb_/left ""))
        (#t
         (@left)
         (let ((//c (@components (@item))))
           (@delete)
           (@down)
           (@splice_before //c)
           (@up)))))

