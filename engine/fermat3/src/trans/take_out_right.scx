(define (@take_out_right_test)
  (cond ((and (= (@gt (@i)) //t_/assign)
              (@up?)
              (not (@left?))
              (not (@right?)))
         (@up)))
  (cond ((not (= (@gt (@i)) //t_/statement))
         (@fail "The selected item is not a Statement."))
        ((@right?)
         (@fail "There is a statement to the right of this one."))
        ((not (@up?))
         (@fail "There is no structure out of which to take this item."))
        ((not (null? (@set_intersect
                       (@stat_types (@i))
                       //ext_/call_/types_/set)))
         (@fail "There are undetermined procedure or function calls in the selected item."))
        (#t
         (let ((//s (@i)) (//orig_/a/s (@as_type)))
           (@save_state)
           (@delete)
           (@up)
           (cond ((not (@up?))
                  (@fail "There is no structure out of which to take this item."))
                 (#t
                  (@up)
                  (cond ((= (@st (@i)) //t_/for)
                         (@take_out_right_test_for //s))
                        ((= (@st (@i)) //t_/var)
                         (@take_out_right_test_var //s))
                        ((= (@st (@i)) //t_/where)
                         (@take_out_right_test_where //s))
                        ((= (@st (@i)) //t_/while)
                         (@take_out_right_test_while //s))
                        ((and (= (@gt (@i)) //t_/guarded)
                              (not (= (@st (@parent)) //t_/d_/do)))
                         (@take_out_right_test_guarded //s //orig_/a/s))
                        (#t
                         (@fail "The enclosing item is not of a suitable type.")))))
           (@undo)))))

(define (@take_out_right_test_for //s)
  (cond ((not (null? (@set_intersect (@assigned //s) (@used //s))))
         (@fail "A statement cannot be taken out of a `For' if it could assign to variables it uses."))
        (#t
         (let ((//l (@v (list-ref (@i) (+ 1 1))))
               (//e1 (list-ref (@i) (+ 1 2)))
               (//e2 (list-ref (@i) (+ 1 3)))
               (//e3 (list-ref (@i) (+ 1 4)))
               (//body (list-ref (@i) (+ 1 5)))
               (//assd (@assigned //s)))
           (cond ((member //l (@variables //s))
                  (@fail "The statement uses the loop index."))
                 ((not (null? (@set_intersect //assd (@used //body))))
                  (@fail "The statement changes variables which are used in the loop body"))
                 ((not (or (and (@true?
                                  (@make 315
                                         '()
                                         (list (@var_to_expn //e3)
                                               (@make 205 0 '()))))
                                (@true?
                                  (@make 317
                                         '()
                                         (list (@var_to_expn //e2)
                                               (@var_to_expn //e1)))))
                           (and (@true?
                                  (@make 314
                                         '()
                                         (list (@var_to_expn //e3)
                                               (@make 205 0 '()))))
                                (@true?
                                  (@make 316
                                         '()
                                         (list (@var_to_expn //e2)
                                               (@var_to_expn //e1)))))))
                  (@fail "Cannot prove that the loop will be executed."))
                 (#t (@pass)))))))

(define (@take_out_right_test_var //s)
  (let ((//local (@assigned (list-ref (@i) (+ 1 1)))))
    (cond ((not (null? (@set_intersect //local (@variables //s))))
           (@fail "The selected statement being uses some of the local variables."))
          ((not (null? (@set_intersect
                         (@stat_types //s)
                         (@make_set
                           (list //t_/m/w_/proc_/call //t_/proc_/call)))))
           (@fail "Calls in the statement may use the local variables"))
          (#t (@pass)))))

(define (@take_out_right_test_where //s)
  (let ((//d (@make_set
               (let ((l (@cs (list-ref (@i) (+ 1 2))))
                     (map-result '()))
                 (let while-loop ()
                   (cond ((not (null? l))
                          (set! map-result (cons (@v1 (car l)) map-result))
                          (set! l (cdr l))
                          (while-loop))
                         (#t #t)))
                 (reverse map-result)))))
    (cond ((not (null? (@set_intersect
                         //d
                         (@make_set
                           (concat
                             (let ((l (@proc_calls //s)) (map-result '()))
                               (let while-loop ()
                                 (cond ((not (null? l))
                                        (set! map-result
                                          (cons (car (car l)) map-result))
                                        (set! l (cdr l))
                                        (while-loop))
                                       (#t #t)))
                               (reverse map-result))
                             (let ((l (@funct_calls //s)) (map-result '()))
                               (let while-loop ()
                                 (cond ((not (null? l))
                                        (set! map-result
                                          (cons (car (car l)) map-result))
                                        (set! l (cdr l))
                                        (while-loop))
                                       (#t #t)))
                               (reverse map-result)))))))
           (@fail "The statement being taken out uses some of the definitions."))
          (#t (@pass)))))

(define (@take_out_right_test_while //s)
  (cond ((not (null? (@set_intersect (@assigned //s) (@used //s))))
         (@fail "A statement cannot be taken out into a `While' if it could assign to variables it uses."))
        (#t
         (let ((//b (list-ref (@i) (+ 1 1))))
           (cond ((not (null? (@set_intersect
                                (@assigned //s)
                                (@variables (@i)))))
                  (@fail "The loop used some variables assigned in the other statement."))
                 ((or (not (@left?))
                      (not (= (@st (list-ref (@parent) (+ 1 (- (@posn_n) 1))))
                              //t_/assert)))
                  (@fail "There is no assertion before the loop."))
                 (#t
                  (@left)
                  (cond ((not (@implies? (list-ref (@i) (+ 1 1)) //b))
                         (@fail "The assertion does not imply that the loop executes."))
                        ((not (null? (@set_intersect
                                       (@assigned //s)
                                       (@variables (@i)))))
                         (@fail "The assertion could be changed by the statement being taken out."))
                        (#t (@pass)))))))))

(define (@take_out_right_test_guarded //s //a/s_/type)
  (let ((//p (@posn_n)) (//a (@assigned //s)))
    (let while-loop ()
      (cond ((and (not (@failed?)) (@left?))
             (begin
               (@left)
               (cond ((member
                        0
                        (@gen_tvs (list-ref (@i) (+ 1 2)) //a/s_/type))
                      (@down_last)
                      (@down_last)
                      (cond ((not (or (@equal? (@i) //s)
                                      (and (= (@st (@i)) //t_/exit)
                                           (> (@v (@i)) 1))))
                             (@fail "The selected statement does not end each guard.")))
                      (@up)
                      (@up))))
             (while-loop))
            (#t #t)))
    (@to //p)
    (let while-loop ()
      (cond ((and (not (@failed?)) (@right?))
             (begin
               (@right)
               (cond ((member
                        0
                        (@gen_tvs (list-ref (@i) (+ 1 2)) //a/s_/type))
                      (@down_last)
                      (@down_last)
                      (cond ((not (or (@equal? (@i) //s)
                                      (and (= (@st (@i)) //t_/exit)
                                           (> (@v (@i)) 1))))
                             (@fail "The selected statement does not end each guard.")))
                      (@up)
                      (@up))))
             (while-loop))
            (#t #t)))
    (cond ((not (@failed?)) (@pass)))))

(define (@take_out_right_code //data)
  (cond ((and (= (@gt (@i)) //t_/assign)
              (@up?)
              (not (@left?))
              (not (@right?)))
         (@up)))
  (let ((//s (@i)) (//p1 '()) (//p2 '()) (//p3 '()))
    (set! //p1 (@posn_n))
    (@up)
    (set! //p2 (@posn_n))
    (@up)
    (cond ((= (@gt (@i)) //t_/guarded)
           (@up)
           (@edit_parent)
           (@down)
           (set! /fl_flag1 0)
           (let while-loop ()
             (cond ((= /fl_flag1 0)
                    (begin
                      (@down_last)
                      (@down_last)
                      (cond ((@equal? (@i) //s) (@delete)))
                      (@up)
                      (@up)
                      (cond ((not (@right?)) (set! /fl_flag1 1))
                            (#t (@right) (set! /fl_flag1 0))))
                    (while-loop))
                   (#t #t)))
           (@up)
           (@paste_after //s)
           (cond ((= (@st (@i)) //t_/cond) (@fix_cond))
                 (#t (@fix_dijkstra)))
           (@end_edit))
          (#t
           (@edit_parent)
           (@paste_after //s)
           (@down_to //p2)
           (@down_to //p1)
           (@clever_delete)
           (@end_edit)))))

#t

