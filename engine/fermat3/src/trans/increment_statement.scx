(define (@increment_statement_test)
  (let ((/tvs '()) (/posn-save /posn) (/min 0))
    (set! /posn '())
    (cond ((and (= (@gt (@item)) //t_/assign)
                (@up?)
                (not (@left?))
                (not (@right?)))
           (@up)))
    (cond ((= (@gt (@i)) //t_/statements) (@down_last)))
    (set! /tvs (@sort_num (@tvs)))
    (cond ((not (= (@gt (@i)) //t_/statement))
           (@fail "Current item is not a statement"))
          ((not (@up?))
           (@fail "Statement is not in an enclosing loop"))
          ((null? /tvs)
           (@fail "Statement is an infinite loop"))
          (#t
           (set! /min (car /tvs))
           (set! /posn (@up_to_loop /posn))
           (let while-loop ()
             (cond ((and (> /min 0) (not (null? /posn)))
                    (begin
                      (set! /min (- /min 1))
                      (set! /posn (@up_to_loop /posn)))
                    (while-loop))
                   (#t #t)))
           (cond ((null? /posn)
                  (@fail "Statement is not in an enclosing loop"))
                 ((< (if (vector? (@posn))
                       (vector-length (@posn))
                       (length (@posn)))
                     2)
                  (@fail "Statement is not in an enclosing double loop"))
                 ((or (not (= (@st (@gparent)) //t_/floop))
                      (> (@size (@parent)) 1))
                  (@fail "Statement is not in an enclosing double loop"))
                 ((and (> (if (vector? /tvs)
                            (vector-length /tvs)
                            (length /tvs))
                          1)
                       (not (@is_enclosing_loops?
                              (+ (- (last-1 /tvs) (car /tvs)) 1))))
                  (@fail "Statement is not surrounded by enough nested loops"))
                 ((not (@gen_terminal?
                         (list-ref (@i) (+ 1 1))
                         (cdr /posn)
                         (@as_type)))
                  (@fail "Statement is not in a terminal position in enclosing double loop"))
                 (#t (@pass)))))
    (set! /posn /posn-save)))

(define (@increment_statement_code //data)
  (cond ((and (= (@gt (@item)) //t_/assign)
              (@up?)
              (not (@left?))
              (not (@right?)))
         (@up)))
  (cond ((= (@gt (@i)) //t_/statements) (@down_last)))
  (@splice_over (@increment (@i) (@as_type) 1 0)))

(define (@up_to_loop /posn-par)
  (let ((/posn-save /posn) (funct-result '()))
    (set! /posn /posn-par)
    (let ((/len (if (vector? /posn)
                  (vector-length /posn)
                  (length /posn))))
      (cond ((not (@up?)) (set! /posn '()))
            (#t
             (set! /posn (cons (@posn_n) /posn))
             (@up)
             (let while-loop ()
               (cond ((and (not (= //t_/floop (@st (@i)))) (@up?))
                      (begin (set! /posn (cons (@posn_n) /posn)) (@up))
                      (while-loop))
                     (#t #t)))
             (cond ((not (= (@st (@i)) //t_/floop))
                    (let ((/n (- (if (vector? /posn)
                                   (vector-length /posn)
                                   (length /posn))
                                 /len)))
                      (let while-loop ()
                        (cond ((> /n 0)
                               (begin
                                 (@down_to (car /posn))
                                 (set! /posn (cdr /posn))
                                 (set! /n (- /n 1)))
                               (while-loop))
                              (#t #t)))
                      (set! /posn '())))))))
    (set! funct-result /posn)
    (set! /posn /posn-save)
    funct-result))

(define (@is_enclosing_loops? /n)
  (let ((/orig (@posn))
        (/posn-save /posn)
        (funct-result '()))
    (set! /posn '())
    (let while-loop ()
      (cond ((> /n 0)
             (begin
               (set! /posn (@up_to_loop /posn))
               (set! /n (- /n 1)))
             (while-loop))
            (#t #t)))
    (@goto /orig)
    (set! funct-result (not (null? /posn)))
    (set! /posn /posn-save)
    funct-result))

#t

