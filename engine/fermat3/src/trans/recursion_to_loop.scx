(define (/foreach-recursion_to_loop-1
         //depth
         //a/s_/type)
  (cond ((or (and (= (@st (@i)) //t_/call)
                  (equal? (@v (@i)) //n))
             (and (= (@st (@i)) //t_/proc_/call)
                  (equal? (@v (list-ref (@i) (+ 1 1))) //n)))
         (set! //calls (concat //calls (list (@posn)))))))

(define (/foreach-recursion_to_loop-2
         //depth
         //a/s_/type)
  (cond ((or (and (= /type //t_/action)
                  (= (@st (@i)) //t_/call)
                  (equal? (@v (@i)) //n))
             (and (= /type //t_/proc)
                  (= (@st (@i)) //t_/proc_/call)
                  (equal? (@v (list-ref (@i) (+ 1 1))) //n)))
         (cond ((= (@st /orig) //t_/proc)
                (cond ((@terminal_posn? /orig (@posn))
                       (@paste_over (@make //t_/exit (+ //depth 1) '())))))
               (#t
                (@paste_over (@make //t_/exit (+ //depth 1) '())))))))

(define (/foreach-recursion_to_loop-3
         //depth
         //a/s_/type)
  (@down)
  (let while-loop ()
    (cond ((and (not (= //t_/call (@st (@i)))) (@right?))
           (@right)
           (while-loop))
          (#t #t)))
  (cond ((= //t_/call (@st (@i)))
         (@cut_rest)
         (@paste_over (@make //t_/exit //depth '())))))

(define (/foreach-recursion_to_loop-4
         //depth
         //a/s_/type)
  (cond ((= (@st (@i)) //t_/call)
         (@paste_after (@make //t_/exit //depth '())))))

(define (@recursion_to_loop_test)
  (cond ((= (@st (@item)) //t_/action)
         (let ((//n-save //n))
           (set! //n (@v (list-ref (@item) (+ 1 1))))
           (cond ((not (@called? //n (@item)))
                  (@fail "Action is not recursive"))
                 ((@any_call_in_var? //n)
                  (@fail "A call is inside a VAR"))
                 ((@in_reg_system?) (@pass))
                 ((and (@tail_recursive? //n)
                       (= (if (vector? (@calls (@i)))
                            (vector-length (@calls (@i)))
                            (length (@calls (@i))))
                          1))
                  (@pass))
                 ((and (@tail_recursive? //n)
                       (= (if (vector? (@calls (@i)))
                            (vector-length (@calls (@i)))
                            (length (@calls (@i))))
                          2)
                       (@regular? (@i))
                       (@all_tail_recursive? //n (@calls (@i))))
                  (@pass))
                 (#t (@fail "Cannot remove recursion")))
           (set! //n //n-save)))
        ((and (= (@st (@item)) //t_/proc)
              (or (> (@size (list-ref (@i) (+ 1 3))) 0)
                  (> (@size (list-ref (@i) (+ 1 2))) 0)))
         (@fail "Procedure has parameters -- not yet implemented"))
        ((= (@st (@item)) //t_/proc)
         (let ((//n-save //n))
           (set! //n (@v (list-ref (@item) (+ 1 1))))
           (cond ((not (member
                         //n
                         (let ((l (@proc_calls (@i))) (map-result '()))
                           (let while-loop ()
                             (cond ((not (null? l))
                                    (set! map-result
                                      (cons (car (car l)) map-result))
                                    (set! l (cdr l))
                                    (while-loop))
                                   (#t #t)))
                           (reverse map-result))))
                  (@fail "Procedure is not recursive"))
                 ((not (@any_tail_recursive? //n))
                  (@fail "Procedure has no tail-recursive calls"))
                 ((@any_call_in_var? //n)
                  (@fail "A call is inside a VAR"))
                 (#t (@pass)))
           (set! //n //n-save)))
        (#t
         (@fail "Selected item is not an action or proc"))))

(define (@any_call_in_var? //n-par)
  (let ((//n-save //n)
        (//valid (@reachable_calls //n-par))
        (/found 0)
        (funct-result '()))
    (set! //n //n-par)
    (let while-loop ()
      (cond ((and (not (null? //valid)) (= /found 0))
             (begin
               (cond ((@is_in_var? (car //valid)) (set! /found 1)))
               (set! //valid (cdr //valid)))
             (while-loop))
            (#t #t)))
    (set! funct-result (= /found 1))
    (set! //n //n-save)
    funct-result))

(define (@is_in_var? /posn)
  (let ((/orig-save /orig)
        (/bad 0)
        (/found 0)
        (funct-result '()))
    (set! /orig (@posn))
    (let while-loop ()
      (cond ((and (= /found 0) (not (null? /posn)))
             (begin
               (@down_to (car /posn))
               (set! /posn (cdr /posn))
               (cond ((= (@st (@i)) //t_/var) (set! /found 1))))
             (while-loop))
            (#t #t)))
    (@goto /orig)
    (set! funct-result (= /found 1))
    (set! /orig /orig-save)
    funct-result))

(define (@any_tail_recursive? //n-par)
  (let ((//n-save //n)
        (//valid (@reachable_calls //n-par))
        (//o/k 0)
        (funct-result '()))
    (set! //n //n-par)
    (let while-loop ()
      (cond ((and (not (null? //valid)) (= //o/k 0))
             (begin
               (cond ((@is_terminal_posn? (car //valid))
                      (set! //o/k 1)))
               (set! //valid (cdr //valid)))
             (while-loop))
            (#t #t)))
    (set! funct-result (= //o/k 1))
    (set! //n //n-save)
    funct-result))

(define (@all_tail_recursive? //n-par //l)
  (let ((//n-save //n) (//o/k 1) (funct-result '()))
    (set! //n //n-par)
    (let while-loop ()
      (cond ((and (= //o/k 1) (not (null? //l)))
             (cond ((and (not (equal?
                                (let ((name (let ((name //l))
                                              (if (vector? name)
                                                (vector-ref name (- 1 1))
                                                (list-ref name (- 1 1))))))
                                  (if (vector? name)
                                    (vector-ref name (- 1 1))
                                    (list-ref name (- 1 1))))
                                //n))
                         (= (let ((name (let ((name //l))
                                          (if (vector? name)
                                            (vector-ref name (- 1 1))
                                            (list-ref name (- 1 1))))))
                              (if (vector? name)
                                (vector-ref name (- 2 1))
                                (list-ref name (- 2 1))))
                            1))
                    (set! //l (cdr //l)))
                   ((not (@tail_recursive?
                           (let ((name (let ((name //l))
                                         (if (vector? name)
                                           (vector-ref name (- 1 1))
                                           (list-ref name (- 1 1))))))
                             (if (vector? name)
                               (vector-ref name (- 1 1))
                               (list-ref name (- 1 1))))))
                    (set! //o/k 0))
                   (#t (set! //l (cdr //l))))
             (while-loop))
            (#t #t)))
    (set! funct-result (= //o/k 1))
    (set! //n //n-save)
    funct-result))

(define (@tail_recursive? //n-par)
  (let ((//n-save //n)
        (//valid (@reachable_calls //n-par))
        (//o/k 1)
        (funct-result '()))
    (set! //n //n-par)
    (@down_last)
    (let while-loop ()
      (cond ((and (not (null? //valid)) (= //o/k 1))
             (begin
               (cond ((not (@is_terminal_posn? (cdr (car //valid))))
                      (set! //o/k 0)))
               (set! //valid (cdr //valid)))
             (while-loop))
            (#t #t)))
    (@up)
    (set! funct-result (= //o/k 1))
    (set! //n //n-save)
    funct-result))

(define (@reachable_calls //n-par)
  (let ((//n-save //n)
        (//calls-save //calls)
        (//valid '())
        (//h '())
        (//a/s/type (@as_type))
        (funct-result '()))
    (set! //n //n-par)
    (set! //calls '())
    (@edit)
    (@ateach_statement
      /foreach-recursion_to_loop-1
      0
      (@as_type)
      0)
    (cond ((null? (@program)) (@new_program (@skips))))
    (let while-loop ()
      (cond ((not (null? //calls))
             (begin
               (set! //h (car //calls))
               (cond ((@gen_reachable? (@i) //h //a/s/type)
                      (set! //valid (concat //valid (list //h)))))
               (set! //calls (cdr //calls)))
             (while-loop))
            (#t #t)))
    (@undo_edit)
    (set! funct-result //valid)
    (set! //n //n-save)
    (set! //calls //calls-save)
    funct-result))

(define (@recursion_to_loop_code //data)
  (let ((//n-save //n)
        (//a/s/type (@as_type))
        (//calls-save //calls)
        (/type-save /type)
        (/orig-save /orig))
    (set! //n (@v (list-ref (@i) (+ 1 1))))
    (set! //calls '())
    (set! /type (@st (@i)))
    (set! /orig (@i))
    (@trans //t/r_/delete_/unreachable_/code "")
    (@edit)
    (@down_last)
    (@paste_over (@increment (@i) //a/s/type 2 0))
    (@ateach_statement
      /foreach-recursion_to_loop-2
      0
      (@as_type)
      0)
    (cond ((null? (@program)) (@new_program (@skips))))
    (let ((//s (@cs (@i))))
      (cond ((or (= /type //t_/proc)
                 (equal? //a/s/type "Reg"))
             (@paste_over
               (@make 17
                      '()
                      (list (@make 133
                                   '()
                                   (list (@make 17
                                                '()
                                                (list (@make 133
                                                             '()
                                                             (list (@make 17
                                                                          '()
                                                                          //s)))))))))))
            (#t
             (@paste_over
               (@make 17
                      '()
                      (list (@make 133
                                   '()
                                   (list (@make 17
                                                '()
                                                (list (@make 133
                                                             '()
                                                             (list (@make 17
                                                                          '()
                                                                          (append
                                                                            //s
                                                                            (list (@make 117
                                                                                         2
                                                                                         '()))))))))))))))))
    (@down)
    (set! //calls (@calls (@i)))
    (cond ((and (= (if (vector? //calls)
                     (vector-length //calls)
                     (length //calls))
                   1)
                (equal? //a/s/type "Rec"))
           (@foreach_stats
             /foreach-recursion_to_loop-3
             0
             (@as_type)
             0)
           (cond ((null? (@program)) (@new_program (@skips))))
           (@paste_after
             (@make //t_/call (car (car //calls)) '()))
           (@right)
           (@splice_after
             (@increment_list (@buffer) //a/s/type (- 2) 0)))
          (#t
           (@foreach_statement
             /foreach-recursion_to_loop-4
             0
             (@as_type)
             0)
           (cond ((null? (@program)) (@new_program (@skips))))))
    (@end_edit)
    (@trans //t/r_/delete_/all_/skips "")
    (@down_last)
    (@down)
    (@trans //t/r_/delete_/unreachable_/code "")
    (cond ((@trans? //t/r_/double_/to_/single_/loop)
           (@trans //t/r_/double_/to_/single_/loop "")))
    (cond ((@trans? //t/r_/separate_/right)
           (@trans //t/r_/separate_/right "")))
    (cond ((@trans? //t/r_/remove_/dummy_/loop)
           (@trans //t/r_/remove_/dummy_/loop "")))
    (@up)
    (@up)
    (cond ((@trans? //t/r_/separate_/right)
           (@trans //t/r_/separate_/right "")))
    (@trans //t/r_/delete_/all_/skips "")
    (set! //n //n-save)
    (set! //calls //calls-save)
    (set! /type /type-save)
    (set! /orig /orig-save)))

