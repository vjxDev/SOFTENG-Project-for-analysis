(define (@globalise_procs_test)
  (cond ((not (= (@st (@i)) //t_/where))
         (@fail "Current item is not a WHERE clause."))
        ((not (@up?))
         (@fail "Current WHERE clause is already as global as possible."))
        ((and (= (@gt (@i)) //t_/statement)
              (= (@size (@parent)) 1)
              (equal? (@posn) (list 1)))
         (@fail "Current WHERE clause is already as global as possible."))
        ((null? (@gp_globalisable_procs
                  (@cs (list-ref (@i) (+ 1 2)))))
         (@fail "The WHERE clause contains no globalisable proc definitions."))
        (#t (@pass))))

(define (@globalise_procs_code //data)
  (let ((/procs
          (@gp_globalisable_procs
            (@cs (list-ref (@i) (+ 1 2)))))
        (/posn '())
        (/defns '())
        (/new '()))
    (let ((var-save /defn)
          (seq-save (@cs (list-ref (@i) (+ 1 2)))))
      (if (vector? seq-save)
        (set! seq-save (vector-elts seq-save)))
      (let for-in-loop ((for-tmp seq-save))
        (cond ((not (null? for-tmp))
               (set! /defn (car for-tmp))
               (cond ((member (@v (list-ref /defn (+ 1 1))) /procs)
                      (begin
                        (display "Globalising: ")
                        (begin
                          (display
                            (@n_string (@v (list-ref /defn (+ 1 1)))))
                          (newline)
                          (force-output)))
                      (set! /defns (cons /defn /defns)))
                     (#t (set! /new (cons /defn /new))))
               (for-in-loop (cdr for-tmp)))
              (#t #t)))
      (set! /defn var-save))
    (cond ((null? /new)
           (@splice_over (@cs (list-ref (@i) (+ 1 1)))))
          (#t
           (@down_to 2)
           (@paste_over
             (@make //t_/definitions '() (reverse /new)))
           (@up)))
    (let while-loop ()
      (cond ((and (@up?) (not (= (@st (@i)) //t_/where)))
             (begin (set! /posn (cons (@posn_n) /posn)) (@up))
             (while-loop))
            (#t #t)))
    (@lp_add_defns /defns)
    (@find_type //t_/where)
    (let while-loop ()
      (cond ((not (null? /posn))
             (cond ((>= (@size (@i)) (car /posn))
                    (@down_to (car /posn))
                    (set! /posn (cdr /posn)))
                   (#t (set! /posn '())))
             (while-loop))
            (#t #t)))))

(define (@gp_globalisable_procs /defns)
  (let ((/procs '()) (/posn (@posn)))
    (let ((var-save /defn) (seq-save /defns))
      (if (vector? seq-save)
        (set! seq-save (vector-elts seq-save)))
      (let for-in-loop ((for-tmp seq-save))
        (cond ((not (null? for-tmp))
               (set! /defn (car for-tmp))
               (cond ((= (@st /defn) //t_/proc)
                      (set! /procs
                        (@set_union
                          (list (@v (list-ref /defn (+ 1 1))))
                          /procs))))
               (for-in-loop (cdr for-tmp)))
              (#t #t)))
      (set! /defn var-save))
    (cond ((@up?) (@up)))
    (let while-loop ()
      (cond ((and (@up?) (not (= (@st (@i)) //t_/where)))
             (@up)
             (while-loop))
            (#t #t)))
    (cond ((= (@st (@i)) //t_/where) (@down)))
    (set! /procs
      (@set_difference
        /procs
        (@make_set
          (let ((l (@proc_calls (@i))) (map-result '()))
            (let while-loop ()
              (cond ((not (null? l))
                     (set! map-result (cons (car (car l)) map-result))
                     (set! l (cdr l))
                     (while-loop))
                    (#t #t)))
            (reverse map-result)))))
    (@goto /posn)
    /procs))

#t

