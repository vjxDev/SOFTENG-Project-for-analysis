(define (/foreach-array_to_vars-1 //depth //a/s_/type)
  (cond ((and (= (@st (@i)) //t_/variable)
              (equal? (@v (@i)) (@v /ar)))
         (cond ((or (not (= (@st (@parent)) //t_/aref))
                    (not (= (@st (list-ref
                                   (list-ref (@parent) (+ 1 2))
                                   (+ 1 1)))
                            //t_/number)))
                (@fail "Bad reference found to the array variable"))))))

(define (/foreach-array_to_vars-2 //depth //a/s_/type)
  (cond ((and (= (@st (@i)) //t_/var_/lvalue)
              (equal? (@v (@i)) (@v /ar)))
         (cond ((or (not (= (@st (@parent)) //t_/aref_/lvalue))
                    (not (= (@st (list-ref
                                   (list-ref (@parent) (+ 1 2))
                                   (+ 1 1)))
                            //t_/number)))
                (@fail "Bad reference found to the array variable"))))))

(define (/foreach-array_to_vars-3 //depth //a/s_/type)
  (cond ((and (= (@st (@i)) //t_/aref)
              (= (@st (list-ref (@i) (+ 1 1))) //t_/variable)
              (equal? (@v (list-ref (@i) (+ 1 1))) (@v /ar)))
         (@paste_over
           (@make //t_/variable
                  (let ((name /vars))
                    (if (vector? name)
                      (vector-ref
                        name
                        (- (@v (list-ref (list-ref (@i) (+ 1 2)) (+ 1 1)))
                           1))
                      (list-ref
                        name
                        (- (@v (list-ref (list-ref (@i) (+ 1 2)) (+ 1 1)))
                           1))))
                  '())))))

(define (/foreach-array_to_vars-4 //depth //a/s_/type)
  (cond ((and (= (@st (@i)) //t_/aref_/lvalue)
              (= (@st (list-ref (@i) (+ 1 1)))
                 //t_/var_/lvalue)
              (equal? (@v (list-ref (@i) (+ 1 1))) (@v /ar)))
         (@paste_over
           (@make //t_/var_/lvalue
                  (let ((name /vars))
                    (if (vector? name)
                      (vector-ref
                        name
                        (- (@v (list-ref (list-ref (@i) (+ 1 2)) (+ 1 1)))
                           1))
                      (list-ref
                        name
                        (- (@v (list-ref (list-ref (@i) (+ 1 2)) (+ 1 1)))
                           1))))
                  '())))))

(define (@array_to_vars_test)
  (cond ((not (= (@st (@i)) //t_/var))
         (@fail "Current item is not a local variable statement"))
        (#t
         (let ((/ar-save /ar))
           (set! /ar '())
           (let ((var-save /assign)
                 (seq-save (@cs (list-ref (@i) (+ 1 1)))))
             (if (vector? seq-save)
               (set! seq-save (vector-elts seq-save)))
             (let for-in-loop ((for-tmp seq-save))
               (cond ((not (null? for-tmp))
                      (set! /assign (car for-tmp))
                      (cond ((and (= (@st (list-ref /assign (+ 1 1)))
                                     //t_/var_/lvalue)
                                  (= (@st (list-ref /assign (+ 1 2)))
                                     //t_/array)
                                  (= (@st (list-ref
                                            (list-ref /assign (+ 1 2))
                                            (+ 1 1)))
                                     //t_/number))
                             (set! /ar (list-ref /assign (+ 1 1)))))
                      (for-in-loop (cdr for-tmp)))
                     (#t #t)))
             (set! /assign var-save))
           (cond ((null? /ar)
                  (@fail "No array assignment in the VAR"))
                 (#t
                  (@down_to 2)
                  (@av_test_statements /ar)
                  (cond ((and (not (@failed?))
                              (member //t_/proc_/call (@stat_types (@i))))
                         (let ((/posn (@posn)) (/procs (@av_find_called)))
                           (let ((var-save /proc) (seq-save /procs))
                             (if (vector? seq-save)
                               (set! seq-save (vector-elts seq-save)))
                             (let for-in-loop ((for-tmp seq-save))
                               (cond ((not (null? for-tmp))
                                      (set! /proc (car for-tmp))
                                      (begin
                                        (@goto /proc)
                                        (cond ((or (member
                                                     /ar
                                                     (@variables
                                                       (list-ref (@i) (+ 1 3))))
                                                   (member
                                                     /ar
                                                     (@variables
                                                       (list-ref
                                                         (@i)
                                                         (+ 1 2)))))
                                               (@fail "The array appears as a parameter"))
                                              (#t
                                               (@down_to 4)
                                               (@av_test_statements /ar))))
                                      (for-in-loop (cdr for-tmp)))
                                     (#t #t)))
                             (set! /proc var-save)))))
                  (cond ((not (@failed?)) (@pass)))))
           (set! /ar /ar-save)))))

(define (@array_to_vars_code //data)
  (let ((/ar-save /ar)
        (/str "")
        (/vars-save /vars)
        (/val '())
        (/new '())
        (/all (@all_variables (@i)))
        (/i 1)
        (/v '()))
    (set! /ar '())
    (set! /vars '())
    (let ((var-save /assign)
          (seq-save (@cs (list-ref (@i) (+ 1 1)))))
      (if (vector? seq-save)
        (set! seq-save (vector-elts seq-save)))
      (let for-in-loop ((for-tmp seq-save))
        (cond ((not (null? for-tmp))
               (set! /assign (car for-tmp))
               (cond ((and (= (@st (list-ref /assign (+ 1 1)))
                              //t_/var_/lvalue)
                           (= (@st (list-ref /assign (+ 1 2))) //t_/array)
                           (= (@st (list-ref
                                     (list-ref /assign (+ 1 2))
                                     (+ 1 1)))
                              //t_/number))
                      (set! /ar (list-ref /assign (+ 1 1)))
                      (set! /val
                        (list-ref (list-ref /assign (+ 1 2)) (+ 1 2)))
                      (set! /str
                        (string-append (@n_string (@v /ar)) "_"))
                      (set! /vars '())
                      (set! /i 1)
                      (set! /v (@make_name (concat /str (@string /i))))
                      (let while-loop ()
                        (cond ((member /v /all)
                               (begin
                                 (set! /i (+ /i 1))
                                 (set! /v
                                   (@make_name (concat /str (@string /i)))))
                               (while-loop))
                              (#t #t)))
                      (let ((var-save /j)
                            (for-step 1)
                            (for-end
                              (- (+ (@v (list-ref
                                          (list-ref /assign (+ 1 2))
                                          (+ 1 1)))
                                    /i)
                                 1)))
                        (set! /j /i)
                        (let for-loop ()
                          (cond ((or (and (> 1 0) (<= /j for-end))
                                     (and (< 1 0) (>= /j for-end)))
                                 (set! /vars
                                   (cons (@make_name (concat /str (@string /j)))
                                         /vars))
                                 (set! /j (+ /j for-step))
                                 (for-loop))
                                (#t #t)))
                        (set! /j var-save))))
               (for-in-loop (cdr for-tmp)))
              (#t #t)))
      (set! /assign var-save))
    (let ((var-save /var) (seq-save /vars))
      (if (vector? seq-save)
        (set! seq-save (vector-elts seq-save)))
      (let for-in-loop ((for-tmp seq-save))
        (cond ((not (null? for-tmp))
               (set! /var (car for-tmp))
               (set! /new
                 (cons (@make //t_/assign
                              '()
                              (list (@make //t_/var_/lvalue /var '()) /val))
                       /new))
               (for-in-loop (cdr for-tmp)))
              (#t #t)))
      (set! /var var-save))
    (set! /vars (reverse /vars))
    (@down_to 2)
    (@av_process_statements /ar /vars)
    (let ((/posn (@posn)))
      (let ((var-save /pos) (seq-save (@av_find_called)))
        (if (vector? seq-save)
          (set! seq-save (vector-elts seq-save)))
        (let for-in-loop ((for-tmp seq-save))
          (cond ((not (null? for-tmp))
                 (set! /pos (car for-tmp))
                 (begin
                   (@goto /pos)
                   (@av_process_statements /ar /vars))
                 (for-in-loop (cdr for-tmp)))
                (#t #t)))
        (set! /pos var-save))
      (@goto /posn))
    (@left)
    (@down)
    (let while-loop ()
      (cond ((and (@right?)
                  (not (@equal? (list-ref (@i) (+ 1 1)) /ar)))
             (@right)
             (while-loop))
            (#t #t)))
    (cond ((@equal? (list-ref (@i) (+ 1 1)) /ar)
           (@splice_over /new)))
    (@up)
    (@up)
    (cond ((= (@size (list-ref (@i) (+ 1 1))) 0)
           (@splice_over (@cs (list-ref (@i) (+ 1 2))))))
    (set! /ar /ar-save)
    (set! /vars /vars-save)))

(define (@av_find_called)
  (let ((/posn (@posn))
        (/todo (let ((l (@proc_calls (@i))) (map-result '()))
                 (let while-loop ()
                   (cond ((not (null? l))
                          (set! map-result (cons (car (car l)) map-result))
                          (set! l (cdr l))
                          (while-loop))
                         (#t #t)))
                 (reverse map-result)))
        (/done (my-make-hash-table 16))
        (/name '())
        (/body (my-make-hash-table 16))
        (/proc_posn (my-make-hash-table 16))
        (/posns '()))
    (let while-loop ()
      (cond ((and (@up?) (not (= (@st (@i)) //t_/where)))
             (@up)
             (while-loop))
            (#t #t)))
    (cond ((not (= (@st (@i)) //t_/where))
           (set! /todo '()))
          (#t
           (@down_to 2)
           (@down)
           (cond ((= //t_/proc (@st (@i)))
                  (set! /name (@v (list-ref (@i) (+ 1 1))))
                  (puthash /body /name (list-ref (@i) (+ 1 4)))
                  (puthash /proc_posn /name (@posn))))
           (let while-loop ()
             (cond ((@right?)
                    (begin
                      (@right)
                      (cond ((= //t_/proc (@st (@i)))
                             (set! /name (@v (list-ref (@i) (+ 1 1))))
                             (puthash /body /name (list-ref (@i) (+ 1 4)))
                             (puthash /proc_posn /name (@posn)))))
                    (while-loop))
                   (#t #t)))))
    (let while-loop ()
      (cond ((not (null? /todo))
             (begin
               (set! /name (car /todo))
               (set! /todo (cdr /todo))
               (cond ((null? (gethash /done /name))
                      (puthash /done /name 1)
                      (set! /posns
                        (cons (gethash /proc_posn /name) /posns))
                      (let ((var-save /pair)
                            (seq-save (@proc_calls (gethash /body /name))))
                        (if (vector? seq-save)
                          (set! seq-save (vector-elts seq-save)))
                        (let for-in-loop ((for-tmp seq-save))
                          (cond ((not (null? for-tmp))
                                 (set! /pair (car for-tmp))
                                 (cond ((null? (gethash /done (car /pair)))
                                        (set! /todo (cons (car /pair) /todo))))
                                 (for-in-loop (cdr for-tmp)))
                                (#t #t)))
                        (set! /pair var-save)))))
             (while-loop))
            (#t #t)))
    (@goto /posn)
    /posns))

(define (@av_test_statements /ar-par)
  (let ((/ar-save /ar))
    (set! /ar /ar-par)
    (@ateach_expn
      /foreach-array_to_vars-1
      0
      (@as_type)
      0)
    (cond ((null? (@program)) (@new_program (@skips))))
    (@ateach_lvalue
      /foreach-array_to_vars-2
      0
      (@as_type)
      0)
    (cond ((null? (@program)) (@new_program (@skips))))
    (set! /ar /ar-save)))

(define (@av_process_statements /ar-par /vars-par)
  (let ((/vars-save /vars) (/ar-save /ar))
    (set! /vars /vars-par)
    (set! /ar /ar-par)
    (@foreach_expn
      /foreach-array_to_vars-3
      0
      (@as_type)
      0)
    (cond ((null? (@program)) (@new_program (@skips))))
    (@foreach_lvalue
      /foreach-array_to_vars-4
      0
      (@as_type)
      0)
    (cond ((null? (@program)) (@new_program (@skips))))
    (set! /vars /vars-save)
    (set! /ar /ar-save)))

#t

