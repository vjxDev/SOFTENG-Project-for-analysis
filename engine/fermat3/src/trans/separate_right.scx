(define (/foreach-separate_right-1 //depth //a/s_/type)
  (cond ((equal?
           (@gen_tvs (@i) //a/s/type)
           (list (+ //depth //t)))
         (set! //n (+ //n 1))
         (cond ((@left?)
                (@left)
                (cond ((not (@gen_proper? (@i) //a/s/type))
                       (set! //o/k 0))
                      (#t (set! //s (@i))))
                (@right))
               (#t (set! //o/k 0)))
         (cond ((> //n 1)
                (cond ((not (@equal? //s //s1)) (set! //o/k 0))))
               ((null? //s) (set! //o/k 0))
               (#t (set! //s1 //s))))))

(define (/foreach-separate_right-2 //depth //a/s_/type)
  (cond ((= (@st (@i)) //t_/call)
         (set! //s (@i))
         (@paste_over (@make //t_/exit //depth '())))))

(define (/foreach-separate_right-3 //depth //a/s_/type)
  (cond ((equal?
           (@gen_tvs (@i) //a/s/type)
           (list (+ //depth //t)))
         (set! //p/p (cons (list (@posn) //depth) //p/p))
         (cond ((@right?) (@delete_rest)))
         (set! /tail '())
         (set! /fl_flag1 0)
         (let while-loop ()
           (cond ((= /fl_flag1 0)
                  (cond ((not (@left?)) (set! /fl_flag1 1))
                        (#t
                         (@left)
                         (cond ((not (@gen_proper? (@i) //a/s/type))
                                (set! /fl_flag1 1))
                               (#t
                                (set! /tail (cons (@i) /tail))
                                (set! /fl_flag1 0)))))
                  (while-loop))
                 (#t #t)))
         (let while-loop ()
           (cond ((@right?) (@right) (while-loop)) (#t #t)))
         (cond ((null? //take_/out) (set! //take_/out /tail))
               (#t
                (set! //take_/out (@lc_suffix //take_/out /tail)))))))

(define (@separate_right_test)
  (let ((//s-save //s)
        (//f 0)
        (//count 1)
        (//all_/the_/same 1)
        (//type (@st (@i)))
        (//o/k-save //o/k)
        (//message-save //message))
    (set! //s '())
    (set! //o/k 0)
    (set! //message "")
    (cond ((and (or (= //type //t_/cond) (= //type //t_/d_/if))
                (<= (@size (@i)) //max_/cond_/size))
           (@down_last)
           (@down_last)
           (@down_last)
           (set! //s (@i))
           (cond ((@is_improper?) (set! //f 1)))
           (@up)
           (@up)
           (set! /fl_flag1 0)
           (let while-loop ()
             (cond ((= /fl_flag1 0)
                    (begin
                      (cond ((not (@left?)) (set! /fl_flag1 1))
                            (#t (set! /fl_flag1 0)))
                      (cond ((= /fl_flag1 0)
                             (@left)
                             (@down_last)
                             (@down_last)
                             (cond ((not (@equal? (@i) //s))
                                    (set! //all_/the_/same 0)
                                    (cond ((not (@is_improper?))
                                           (cond ((not (= //f 1))
                                                  (@fail "Nothing to take out")
                                                  (@up)
                                                  (@up)
                                                  (set! /fl_flag1 1))
                                                 (#t
                                                  (set! //f 0)
                                                  (set! //s (@i))
                                                  (set! /fl_flag1 0))))
                                          (#t (set! /fl_flag1 0))))
                                   (#t (set! /fl_flag1 0)))
                             (cond ((= /fl_flag1 0)
                                    (@up)
                                    (@up)
                                    (set! /fl_flag1 0))))))
                    (while-loop))
                   (#t #t)))
           (@up)
           (cond ((and (= //f 1) (= //all_/the_/same 0))
                  (@fail "Not all the same")))
           (cond ((and (not (@failed?))
                       (not (= (@st //s) //t_/skip)))
                  (@pass))
                 (#t (@fail "Nothing to take out")))
           (cond ((@failed?)
                  (cond ((null? (@last_non_comment
                                  (@cs (list-ref
                                         (list-ref (@i) (+ 1 1))
                                         (+ 1 2)))))
                         #t)
                        ((and (= (@size (@i)) 2)
                              (@equal?
                                (@last_non_comment
                                  (@cs (list-ref
                                         (list-ref (@i) (+ 1 1))
                                         (+ 1 2))))
                                (@last_non_comment
                                  (@cs (list-ref
                                         (list-ref (@i) (+ 1 2))
                                         (+ 1 2))))))
                         (@pass))
                        ((and (= (@size (@i)) 3)
                              (@equal?
                                (@last_non_comment
                                  (@cs (list-ref
                                         (list-ref (@i) (+ 1 1))
                                         (+ 1 2))))
                                (@last_non_comment
                                  (@cs (list-ref
                                         (list-ref (@i) (+ 1 2))
                                         (+ 1 2)))))
                              (@equal?
                                (@last_non_comment
                                  (@cs (list-ref
                                         (list-ref (@i) (+ 1 1))
                                         (+ 1 2))))
                                (@last_non_comment
                                  (@cs (list-ref
                                         (list-ref (@i) (+ 1 3))
                                         (+ 1 2))))))
                         (@pass))))))
          ((= //type //t_/where)
           (@down)
           (@down_last)
           (let ((//calls
                   (@make_set
                     (concat
                       (let ((l (@proc_calls (@i))) (map-result '()))
                         (let while-loop ()
                           (cond ((not (null? l))
                                  (set! map-result
                                    (cons (car (car l)) map-result))
                                  (set! l (cdr l))
                                  (while-loop))
                                 (#t #t)))
                         (reverse map-result))
                       (let ((l (@funct_calls (@i))) (map-result '()))
                         (let while-loop ()
                           (cond ((not (null? l))
                                  (set! map-result
                                    (cons (car (car l)) map-result))
                                  (set! l (cdr l))
                                  (while-loop))
                                 (#t #t)))
                         (reverse map-result))))))
             (@up)
             (@up)
             (@down_last)
             (cond ((null? (@set_intersect
                             //calls
                             (@make_set
                               (let ((l (@cs (@i))) (map-result '()))
                                 (let while-loop ()
                                   (cond ((not (null? l))
                                          (set! map-result
                                            (cons (@v1 (car l)) map-result))
                                          (set! l (cdr l))
                                          (while-loop))
                                         (#t #t)))
                                 (reverse map-result)))))
                    (@pass))
                   (#t
                    (@fail "The statement uses procs or functs defined in the WHERE")))))
          ((= //type //t_/var)
           (let ((//v (@assigned (list-ref (@i) (+ 1 1)))))
             (@down_last)
             (@down_last)
             (cond ((not (null? (@set_intersect //v (@variables (@i)))))
                    (@fail "The statement uses the local variables"))
                   ((not (null? (@set_intersect
                                  (@stat_types (@i))
                                  (@make_set
                                    (list //t_/m/w_/proc_/call
                                          //t_/proc_/call)))))
                    (@fail "Calls in the statement may use the local variables"))
                   (#t (@pass)))))
          ((or (= //type //t_/while) (= //type //t_/for))
           (@down_last)
           (@down_last)
           (cond ((@trans? //t/r_/take_/out_/right) (@pass))
                 (#t (@fail "Cannot take anything out"))))
          ((= //type //t_/floop)
           (let ((/-result-
                   (@sr_floop_test (@as_type) //o/k //message)))
             (set! //o/k (car /-result-))
             (set! /-result- (cdr /-result-))
             (set! //message (car /-result-))
             (set! /-result- (cdr /-result-)))
           (cond ((= //o/k 1) (@pass))
                 (#t (@fail //message))))
          ((and (= //type //t_/assignment)
                (> (@size (@i)) 1))
           (let ((/-result- (@sr_assignment_test //o/k //message)))
             (set! //o/k (car /-result-))
             (set! /-result- (cdr /-result-))
             (set! //message (car /-result-))
             (set! /-result- (cdr /-result-)))
           (cond ((= //o/k 1) (@pass))
                 (#t (@fail //message))))
          (#t
           (@fail "Can't separate from this kind of statement")))
    (set! //s //s-save)
    (set! //o/k //o/k-save)
    (set! //message //message-save)))

(define (@sr_floop_test
         //a/s/type-par
         //o/k-par
         //message-par)
  (let ((//message-save //message)
        (//o/k-save //o/k)
        (//a/s/type-save //a/s/type)
        (funct-result '()))
    (set! //message //message-par)
    (set! //o/k //o/k-par)
    (set! //a/s/type //a/s/type-par)
    (let ((//n-save //n)
          (//t-save //t)
          (//s-save //s)
          (//s1-save //s1))
      (set! //n 0)
      (set! //t 0)
      (set! //s '())
      (set! //s1 '())
      (set! //o/k 0)
      (set! //message "Nothing to take out")
      (cond ((equal?
               (@gen_tvs (@i) //a/s/type)
               (list //omega))
             (cond ((and (equal? //a/s/type "Reg")
                         (= (if (vector? (@calls (@i)))
                              (vector-length (@calls (@i)))
                              (length (@calls (@i))))
                            1))
                    (set! //o/k 1))
                   (#t
                    (set! //message "Cannot take out of this loop"))))
            ((equal? (@gen_tvs (@i) //a/s/type) '())
             (set! //message
               "Cannot take anything out of this loop"))
            (#t
             (set! //o/k 1)
             (let while-loop ()
               (cond ((not (member //t (@gen_tvs (@i) //a/s/type)))
                      (set! //t (+ //t 1))
                      (while-loop))
                     (#t #t)))
             (@ateach_terminal
               /foreach-separate_right-1
               0
               (@as_type)
               1)
             (cond ((null? (@program)) (@new_program (@skips))))
             (cond ((and (= //o/k 1) (not (= //n 0)))
                    (set! //o/k 1))
                   (#t (set! //o/k 0)))))
      (set! //n //n-save)
      (set! //t //t-save)
      (set! //s //s-save)
      (set! //s1 //s1-save))
    (set! funct-result (list //o/k //message))
    (set! //message //message-save)
    (set! //o/k //o/k-save)
    (set! //a/s/type //a/s/type-save)
    funct-result))

(define (@sr_assignment_test //o/k-par //message-par)
  (let ((//message-save //message)
        (//o/k-save //o/k)
        (funct-result '()))
    (set! //message //message-par)
    (set! //o/k //o/k-par)
    (let ((/vars '())
          (/last (last-1 (@cs (@i))))
          (/first (butlast-1 (@cs (@i))))
          (/assign '()))
      (let ((var-save /assign) (seq-save /first))
        (if (vector? seq-save)
          (set! seq-save (vector-elts seq-save)))
        (let for-in-loop ((for-tmp seq-save))
          (cond ((not (null? for-tmp))
                 (set! /assign (car for-tmp))
                 (set! /vars
                   (@set_union (@elts_assigned /assign) /vars))
                 (for-in-loop (cdr for-tmp)))
                (#t #t)))
        (set! /assign var-save))
      (cond ((@elt_clash_list? /vars (@elts_used /last))
             (set! //o/k 0)
             (set! //message
               "A variable used in the last assign is assigned to in the others"))
            (#t (set! //o/k 1))))
    (set! funct-result (list //o/k //message))
    (set! //message //message-save)
    (set! //o/k //o/k-save)
    funct-result))

(define (@separate_right_code //data)
  (let ((//orig_/pos (@posn)) (//type (@st (@i))))
    (cond ((or (= //type //t_/cond) (= //type //t_/d_/if))
           (let ((//s-save //s)
                 (//f 1)
                 (//p '())
                 (//o/k-save //o/k))
             (set! //s '())
             (set! //o/k 1)
             (@down)
             (set! //s (last-1 (@cs (list-ref (@i) (+ 1 2)))))
             (set! /fl_flag1 0)
             (let while-loop ()
               (cond ((= /fl_flag1 0)
                      (cond ((not (@right?)) (set! /fl_flag1 1))
                            (#t
                             (@right)
                             (cond ((not (@equal?
                                           //s
                                           (last-1
                                             (@cs (list-ref (@i) (+ 1 2))))))
                                    (set! //f 0)
                                    (set! /fl_flag1 1))
                                   (#t (set! /fl_flag1 0)))))
                      (while-loop))
                     (#t #t)))
             (@to 1)
             (set! //s '())
             (set! /fl_flag1 0)
             (let while-loop ()
               (cond ((= /fl_flag1 0)
                      (begin
                        (@down_last)
                        (@down_last)
                        (cond ((or (= //f 1) (not (@is_improper?)))
                               (cond ((null? //s) (set! //s (@i)))
                                     ((not (@equal? //s (@i)))
                                      (set! //o/k 0)))))
                        (@up)
                        (@up)
                        (cond ((not (@right?)) (set! /fl_flag1 1))
                              (#t (@right) (set! /fl_flag1 0))))
                      (while-loop))
                     (#t #t)))
             (@up)
             (cond ((= //o/k 1)
                    (@paste_after //s)
                    (let ((var-save //j)
                          (for-step 1)
                          (for-end (@size (@i))))
                      (set! //j 1)
                      (let for-loop ()
                        (cond ((or (and (> 1 0) (<= //j for-end))
                                   (and (< 1 0) (>= //j for-end)))
                               (begin
                                 (@down_to //j)
                                 (@down_last)
                                 (@down_last)
                                 (cond ((@equal? //s (@i)) (@delete)))
                                 (@up)
                                 (@up)
                                 (@up))
                               (set! //j (+ //j for-step))
                               (for-loop))
                              (#t #t)))
                      (set! //j var-save)))
                   ((or (and (= (@size (@i)) 2)
                             (@equal?
                               (@last_non_comment
                                 (@cs (list-ref
                                        (list-ref (@i) (+ 1 1))
                                        (+ 1 2))))
                               (@last_non_comment
                                 (@cs (list-ref
                                        (list-ref (@i) (+ 1 2))
                                        (+ 1 2))))))
                        (and (= (@size (@i)) 3)
                             (@equal?
                               (@last_non_comment
                                 (@cs (list-ref
                                        (list-ref (@i) (+ 1 1))
                                        (+ 1 2))))
                               (@last_non_comment
                                 (@cs (list-ref
                                        (list-ref (@i) (+ 1 2))
                                        (+ 1 2)))))
                             (@equal?
                               (@last_non_comment
                                 (@cs (list-ref
                                        (list-ref (@i) (+ 1 1))
                                        (+ 1 2))))
                               (@last_non_comment
                                 (@cs (list-ref
                                        (list-ref (@i) (+ 1 3))
                                        (+ 1 2)))))))
                    (let ((/save '()))
                      (@down)
                      (@down_last)
                      (@down_last)
                      (set! /fl_flag1 0)
                      (let while-loop ()
                        (cond ((= /fl_flag1 0)
                               (begin
                                 (let while-loop ()
                                   (cond ((= (@st (@i)) //t_/comment)
                                          (@left)
                                          (while-loop))
                                         (#t #t)))
                                 (set! //s (@i))
                                 (@delete)
                                 (@up)
                                 (@up)
                                 (cond ((not (@right?)) (set! /fl_flag1 1))
                                       (#t
                                        (@right)
                                        (@down_last)
                                        (@down_last)
                                        (set! /fl_flag1 0))))
                               (while-loop))
                              (#t #t)))
                      (@up)
                      (@splice_after (cons //s /save))))
                   (#t (error "BUG in @Separate_Right_Code!")))
             (cond ((= //type //t_/cond) (@fix_cond))
                   (#t (@fix_dijkstra)))
             (cond ((@right?)
                    (@right)
                    (cond ((= (@st (@i)) //t_/skip) (@delete)))))
             (set! //s //s-save)
             (set! //o/k //o/k-save))
           (@goto //orig_/pos))
          ((= //type //t_/where)
           (@down)
           (@down_last)
           (set! //s (@i))
           (@up)
           (@up)
           (@paste_after //s)
           (@goto (@posn))
           (@down)
           (@down_last)
           (@delete)
           (@fixup)
           (@goto //orig_/pos))
          ((or (= //type //t_/while)
               (= //type //t_/for)
               (= //type //t_/var))
           (@down_last)
           (@down_last)
           (set! //s (@i))
           (@up)
           (@up)
           (@paste_after //s)
           (@goto (@posn))
           (@down_last)
           (@down_last)
           (@delete)
           (@fixup)
           (@goto //orig_/pos))
          ((= //type //t_/floop) (@sr_floop (@as_type)))
          ((= //type //t_/assignment)
           (@down_last)
           (@cut)
           (@up)
           (@paste_after
             (@make //t_/assignment '() (list (@buffer))))))
    (cond ((@trans? //t/r_/separate_/right)
           (@trans //t/r_/separate_/right '())))))

(define (@sr_floop //a/s/type-par)
  (let ((//a/s/type-save //a/s/type))
    (set! //a/s/type //a/s/type-par)
    (let ((//s-save //s)
          (//t-save //t)
          (//p (@posn))
          (//p/p-save //p/p)
          (//d 0)
          (//take_/out-save //take_/out)
          (//s1-save //s1)
          (/tail-save /tail)
          (/taken 0))
      (set! //s '())
      (set! //t 0)
      (set! //p/p '())
      (set! //take_/out '())
      (set! //s1 '())
      (set! /tail '())
      (cond ((equal?
               (@gen_tvs (@i) //a/s/type)
               (list //omega))
             (@foreach_statement
               /foreach-separate_right-2
               0
               (@as_type)
               0)
             (cond ((null? (@program)) (@new_program (@skips))))
             (@paste_after //s)
             (@goto //p))
            (#t
             (let while-loop ()
               (cond ((not (member //t (@gen_tvs (@i) //a/s/type)))
                      (set! //t (+ //t 1))
                      (while-loop))
                     (#t #t)))
             (@edit)
             (@ateach_terminal
               /foreach-separate_right-3
               0
               (@as_type)
               1)
             (cond ((null? (@program)) (@new_program (@skips))))
             (set! //p/p (reverse //p/p))
             (@end_edit)
             (set! /taken
               (if (vector? //take_/out)
                 (vector-length //take_/out)
                 (length //take_/out)))
             (cond ((> //t 0)
                    (set! //take_/out
                      (concat
                        //take_/out
                        (list (@make //t_/exit //t '()))))))
             (@splice_after //take_/out)
             (@goto //p)
             (@edit)
             (let while-loop ()
               (cond ((not (null? //p/p))
                      (begin
                        (@goto (let ((name (let ((name //p/p))
                                             (if (vector? name)
                                               (vector-ref name (- 1 1))
                                               (list-ref name (- 1 1))))))
                                 (if (vector? name)
                                   (vector-ref name (- 1 1))
                                   (list-ref name (- 1 1)))))
                        (@up)
                        (set! //s1 (@cs (@i)))
                        (@paste_over
                          (@make //t_/statements
                                 '()
                                 (concat
                                   (@sub_seg
                                     //s1
                                     1
                                     (- (@size (@i)) (+ /taken 1)))
                                   (list (@make //t_/exit
                                                (let ((name (let ((name //p/p))
                                                              (if (vector? name)
                                                                (vector-ref
                                                                  name
                                                                  (- 1 1))
                                                                (list-ref
                                                                  name
                                                                  (- 1 1))))))
                                                  (if (vector? name)
                                                    (vector-ref name (- 2 1))
                                                    (list-ref name (- 2 1))))
                                                '())))))
                        (set! //p/p (cdr //p/p)))
                      (while-loop))
                     (#t #t)))
             (@end_edit)))
      (set! //s //s-save)
      (set! //t //t-save)
      (set! //p/p //p/p-save)
      (set! //take_/out //take_/out-save)
      (set! //s1 //s1-save)
      (set! /tail /tail-save))
    (set! //a/s/type //a/s/type-save)))

(define (@lc_suffix //l1 //l2)
  (let ((//r '()))
    (set! //l1 (reverse //l1))
    (set! //l2 (reverse //l2))
    (let while-loop ()
      (cond ((and (not (null? //l1))
                  (not (null? //l2))
                  (@equal? (car //l1) (car //l2)))
             (begin
               (set! //r (cons (car //l1) //r))
               (set! //l1 (cdr //l1))
               (set! //l2 (cdr //l2)))
             (while-loop))
            (#t #t)))
    //r))

(define (@last_non_comment //l)
  (let ((//r '()) (//l1 (reverse //l)))
    (let while-loop ()
      (cond ((and (not (null? //l1))
                  (= (@st (car //l1)) //t_/comment))
             (set! //l1 (cdr //l1))
             (while-loop))
            (#t #t)))
    (cond ((not (null? //l1)) (set! //r (car //l1))))
    //r))

#t

