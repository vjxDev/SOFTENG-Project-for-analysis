(define (@separate_left_test)
  (let ((//s '())
        (/types '())
        (//f 0)
        (/assigned '())
        (//v '())
        (//cond_/vars '())
        (//s/t (@st (@i)))
        (/bad_types
          (@make_set
            (list //t_/x_/proc_/call
                  //t_/proc_/call
                  //t_/m/w_/proc_/call)))
        (/funct_types
          (@make_set
            (list //t_/funct_/call //t_/m/w_/funct_/call))))
    (cond ((or (not (@up?))
               (not (= (@gt (@i)) //t_/statement)))
           (@fail "Not in a statement sequence"))
          ((or (= //s/t //t_/cond) (= //s/t //t_/d_/if))
           (@down_last)
           (@down_last)
           (@down)
           (set! //s (@i))
           (set! /types (@stat_types (@i)))
           (cond ((or (= (@st //s) //t_/skip)
                      (not (null? (@set_intersect /bad_types /types))))
                  (@fail "Won't take out skips, can't take out proc calls"))
                 (#t
                  (set! /assigned (@assigned //s))
                  (@up)
                  (@up)
                  (set! /fl_flag1 0)
                  (let while-loop ()
                    (cond ((= /fl_flag1 0)
                           (cond ((not (@left?)) (set! /fl_flag1 1))
                                 (#t
                                  (@left)
                                  (@down_last)
                                  (@down)
                                  (cond ((not (@equal? (@i) //s))
                                         (@fail "Nothing to take out")
                                         (set! /fl_flag1 1))
                                        (#t
                                         (@up)
                                         (@to 1)
                                         (cond ((not (null? (@set_intersect
                                                              (@spec_types (@i))
                                                              /funct_types)))
                                                (@fail "Function calls in condition"))
                                               ((not (null? (@set_intersect
                                                              (@used (@i))
                                                              /assigned)))
                                                (cond ((and (= (@st //s)
                                                               //t_/assignment)
                                                            (@invertible?
                                                              (@set_intersect
                                                                (@used (@i))
                                                                /assigned)
                                                              (@cs //s))))
                                                      (#t
                                                       (@fail "Variable occurs in condition")))))
                                         (@up)
                                         (cond ((@failed?) (set! /fl_flag1 1))
                                               (#t (set! /fl_flag1 0)))))))
                           (while-loop))
                          (#t #t)))))
           (cond ((not (@failed?)) (@pass))))
          ((= //s/t //t_/where)
           (@down)
           (@down)
           (let ((/calls
                   (@make_set
                     (concat
                       (let ((l (@proc_calls (@i))) (map-result '()))
                         (let while-loop ()
                           (cond ((not (null? l))
                                  (set! map-result
                                    (cons (car (car l)) map-result))
                                  (set! l (cdr l))
                                  (while-loop))
                                 (#t #t)))
                         (reverse map-result))
                       (let ((l (@funct_calls (@i))) (map-result '()))
                         (let while-loop ()
                           (cond ((not (null? l))
                                  (set! map-result
                                    (cons (car (car l)) map-result))
                                  (set! l (cdr l))
                                  (while-loop))
                                 (#t #t)))
                         (reverse map-result))))))
             (@up)
             (@right)
             (cond ((null? (@set_intersect
                             /calls
                             (@make_set
                               (let ((l (@cs (@i))) (map-result '()))
                                 (let while-loop ()
                                   (cond ((not (null? l))
                                          (set! map-result
                                            (cons (@v1 (car l)) map-result))
                                          (set! l (cdr l))
                                          (while-loop))
                                         (#t #t)))
                                 (reverse map-result)))))
                    (@pass))
                   (#t
                    (@fail "The statement uses procs or funct defined in the WHERE")))))
          ((= //s/t //t_/var)
           (let ((/local (@assigned (list-ref (@i) (+ 1 1))))
                 (/used (@used (list-ref (@i) (+ 1 1)))))
             (@down_last)
             (@down)
             (cond ((not (null? (@set_intersect /local (@variables (@i)))))
                    (@fail "The statement uses the local variables"))
                   ((not (null? (@set_intersect /used (@assigned (@i)))))
                    (@fail "The statement assigns to variables needed for initalisation"))
                   (#t (@pass)))))
          ((or (= //s/t //t_/while) (= //s/t //t_/for))
           (@down_last)
           (@down)
           (cond ((@trans? //t/r_/take_/out_/left) (@pass))
                 (#t (@fail "Cannot take anything out"))))
          ((and (= //s/t //t_/assignment)
                (> (@size (@i)) 1))
           (let ((/vars '())
                 (/first (list-ref (@i) (+ 1 1)))
                 (/rest (cdr (@cs (@i))))
                 (/assign '()))
             (let ((var-save /assign) (seq-save /rest))
               (if (vector? seq-save)
                 (set! seq-save (vector-elts seq-save)))
               (let for-in-loop ((for-tmp seq-save))
                 (cond ((not (null? for-tmp))
                        (set! /assign (car for-tmp))
                        (set! /vars
                          (@set_union (@elts_used /assign) /vars))
                        (for-in-loop (cdr for-tmp)))
                       (#t #t)))
               (set! /assign var-save))
             (cond ((@elt_clash_list? /vars (@elts_assigned /first))
                    (@fail "The variable assigned in the first assign is used elsewhere."))
                   (#t (@pass)))))
          (#t
           (@fail "Cannot separate from this type of statement")))))

(define (@separate_left_code //data)
  (let ((/posn (@posn))
        (//s/t (@st (@i)))
        (//s '())
        (/assigned '())
        (/i 0)
        (/new '()))
    (cond ((or (= //s/t //t_/cond) (= //s/t //t_/d_/if))
           (@splice_before (list (@get (@i) (list 1 2 1))))
           (set! //s (@i))
           (@right)
           (@edit)
           (cond ((= (@st //s) //t_/assignment)
                  (set! /assigned (@assigned //s))
                  (@down)
                  (set! /fl_flag1 0)
                  (let while-loop ()
                    (cond ((= /fl_flag1 0)
                           (begin
                             (@down)
                             (cond ((not (null? (@set_intersect
                                                  (@used (@i))
                                                  /assigned)))
                                    (@invert_all /assigned (@cs //s))))
                             (@up)
                             (cond ((not (@right?)) (set! /fl_flag1 1))
                                   (#t (@right) (set! /fl_flag1 0))))
                           (while-loop))
                          (#t #t)))
                  (@up)))
           (let ((var-save /i)
                 (for-step 1)
                 (for-end (@size (@i))))
             (set! /i 1)
             (let for-loop ()
               (cond ((or (and (> 1 0) (<= /i for-end))
                          (and (< 1 0) (>= /i for-end)))
                      (begin (@goto (list /i 2 1)) (@delete))
                      (set! /i (+ /i for-step))
                      (for-loop))
                     (#t #t)))
             (set! /i var-save))
           (@end_edit)
           (cond ((= //s/t //t_/cond) (@fix_cond))
                 (#t (@fix_dijkstra))))
          ((= //s/t //t_/where)
           (@splice_before (list (@get (@i) (list 1 1))))
           (@right)
           (@down)
           (@down)
           (@delete)
           (@fixup)
           (@goto /posn)
           (cond ((@right?) (@right))))
          ((or (= //s/t //t_/while)
               (= //s/t //t_/for)
               (= //s/t //t_/var))
           (@down_last)
           (@down)
           (set! //s (@i))
           (@goto /posn)
           (@splice_before (list //s))
           (@right)
           (@down_last)
           (@down)
           (@delete)
           (@fixup)
           (@goto /posn)
           (cond ((@right?) (@right))))
          ((= //s/t //t_/assignment)
           (@down)
           (@cut)
           (@up)
           (@paste_before
             (@make //t_/assignment '() (list (@buffer))))
           (cond ((@right?) (@right))))))
  (cond ((@trans? //t/r_/separate_/left)
         (@trans //t/r_/separate_/left '()))))

