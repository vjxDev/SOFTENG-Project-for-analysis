(define (@yy_expression)
  (let ((//s-save //s)
        (/op 0)
        (/seq 0)
        (funct-result '()))
    (set! //s '())
    (cond ((or (= /token1 //s_/l/a/n/g/l/e)
               (= /token1 //s_/l/b/r/a/c/e)
               (= (let ((name /s_prefix_ops))
                    (if (vector? name)
                      (vector-ref name (- /token1 1))
                      (list-ref name (- /token1 1))))
                  1))
           (set! //s (@yy_s_expression)))
          ((or (= /token1 //s_/n/u/m/b/e/r)
               (= /token1 //s_/m/i/n/u/s)
               (= (let ((name /a_prefix_ops))
                    (if (vector? name)
                      (vector-ref name (- /token1 1))
                      (list-ref name (- /token1 1))))
                  1))
           (set! //s (@yy_a_expression)))
          ((= /token1 //s_/f/i/l/l) (set! //s (@yy_fill)))
          (#t
           (cond ((= /token1 //s_/l/p/a/r/e/n)
                  (@yy_lex)
                  (set! //s (@yy_expression))
                  (cond ((not (= /token1 //s_/r/p/a/r/e/n))
                         (@syntax_error "Missing `)'"))
                        (#t (@yy_lex))))
                 (#t (set! //s (@yy_factor))))
           (cond ((= (let ((name /g_exp_types))
                       (if (vector? name)
                         (vector-ref name (- (@spec_type //s) 1))
                         (list-ref name (- (@spec_type //s) 1))))
                     1)
                  (cond ((or (= /token1 //s_/e/o/f)
                             (= /token1 //s_/s/e/m/i/c/o/l/o/n))
                         #t)
                        ((or (= (let ((name //factor_/ops))
                                  (if (vector? name)
                                    (vector-ref name (- /token1 1))
                                    (list-ref name (- /token1 1))))
                                1)
                             (= (let ((name //term_/ops))
                                  (if (vector? name)
                                    (vector-ref name (- /token1 1))
                                    (list-ref name (- /token1 1))))
                                1))
                         (set! //s (@yy_build_a_expr //s)))
                        ((or (= (let ((name //s_/factor_/ops))
                                  (if (vector? name)
                                    (vector-ref name (- /token1 1))
                                    (list-ref name (- /token1 1))))
                                1)
                             (= (let ((name //s_/term_/ops))
                                  (if (vector? name)
                                    (vector-ref name (- /token1 1))
                                    (list-ref name (- /token1 1))))
                                1)
                             (= (let ((name //s_/atom_/ops))
                                  (if (vector? name)
                                    (vector-ref name (- /token1 1))
                                    (list-ref name (- /token1 1))))
                                1))
                         (set! //s (@yy_build_s_expr //s)))))
                 ((= (let ((name //math_/exps))
                       (if (vector? name)
                         (vector-ref name (- (@spec_type //s) 1))
                         (list-ref name (- (@spec_type //s) 1))))
                     1)
                  (cond ((or (= /token1 //s_/e/o/f)
                             (= /token1 //s_/s/e/m/i/c/o/l/o/n))
                         #t)
                        (#t (set! //s (@yy_build_a_expr //s)))))
                 ((= (let ((name //seq_/exps))
                       (if (vector? name)
                         (vector-ref name (- (@spec_type //s) 1))
                         (list-ref name (- (@spec_type //s) 1))))
                     1)
                  (cond ((or (= /token1 //s_/e/o/f)
                             (= /token1 //s_/s/e/m/i/c/o/l/o/n))
                         #t)
                        (#t (set! //s (@yy_build_s_expr //s)))))
                 (#t
                  (let while-loop ()
                    (cond ((= /token1 //s_/c/a/r/e/t)
                           (begin
                             (@yy_lex)
                             (cond ((= /token1 //s_/c/a/r/e/t)
                                    (@yy_lex)
                                    (set! //s
                                      (@make //t_/get
                                             '()
                                             (list //s (@yy_s_expression)))))
                                   (#t
                                    (set! //s
                                      (@make_get_n //s (@yy_a_expression))))))
                           (while-loop))
                          (#t #t)))))))
    (set! funct-result //s)
    (set! //s //s-save)
    funct-result))

(set! //l_/assoc_/types
  (list //t_/plus
        //t_/times
        //t_/union
        //t_/intersection
        //t_/and
        //t_/or
        //t_/max
        //t_/min
        //t_/minus
        //t_/divide))

(define (@make_assoc /op //s //i)
  (if (member /op //l_/assoc_/types)
    (if (= (@st //s) /op)
      (@make /op '() (concat (@cs //s) (list //i)))
      (@make /op '() (list //s //i)))
    (@make /op '() (list //s //i))))

(define (@yy_build_a_expr //s-par)
  (let ((//s-save //s) (/op '()) (funct-result '()))
    (set! //s //s-par)
    (let while-loop ()
      (cond ((= (let ((name //factor_/ops))
                  (if (vector? name)
                    (vector-ref name (- /token1 1))
                    (list-ref name (- /token1 1))))
                1)
             (begin
               (set! /op (gethash //type_/table /token1))
               (@yy_lex)
               (set! //s (@make_assoc /op //s (@yy_factor))))
             (while-loop))
            (#t #t)))
    (let while-loop ()
      (cond ((= (let ((name //term_/ops))
                  (if (vector? name)
                    (vector-ref name (- /token1 1))
                    (list-ref name (- /token1 1))))
                1)
             (begin
               (set! /op (gethash //type_/table /token1))
               (@yy_lex)
               (set! //s (@make_assoc /op //s (@yy_term))))
             (while-loop))
            (#t #t)))
    (set! funct-result //s)
    (set! //s //s-save)
    funct-result))

(define (@yy_build_s_expr //s-par)
  (let ((//s-save //s) (/op '()) (funct-result '()))
    (set! //s //s-par)
    (let while-loop ()
      (cond ((= (let ((name //s_/atom_/ops))
                  (if (vector? name)
                    (vector-ref name (- /token1 1))
                    (list-ref name (- /token1 1))))
                1)
             (begin
               (set! /op (gethash //type_/table /token1))
               (@yy_lex)
               (set! //s (@make_assoc /op //s (@yy_s_atom))))
             (while-loop))
            (#t #t)))
    (let while-loop ()
      (cond ((= (let ((name //s_/factor_/ops))
                  (if (vector? name)
                    (vector-ref name (- /token1 1))
                    (list-ref name (- /token1 1))))
                1)
             (begin
               (set! /op (gethash //type_/table /token1))
               (@yy_lex)
               (set! //s (@make_assoc /op //s (@yy_s_factor))))
             (while-loop))
            (#t #t)))
    (let while-loop ()
      (cond ((= (let ((name //s_/term_/ops))
                  (if (vector? name)
                    (vector-ref name (- /token1 1))
                    (list-ref name (- /token1 1))))
                1)
             (begin
               (set! /op (gethash //type_/table /token1))
               (@yy_lex)
               (set! //s
                 (@make /op '() (list //s (@yy_s_term)))))
             (while-loop))
            (#t #t)))
    (set! funct-result //s)
    (set! //s //s-save)
    funct-result))

(define (@yy_a_expression)
  (let ((//s-save //s) (/op '()) (funct-result '()))
    (set! //s '())
    (set! //s (@yy_term))
    (let while-loop ()
      (cond ((= (let ((name //term_/ops))
                  (if (vector? name)
                    (vector-ref name (- /token1 1))
                    (list-ref name (- /token1 1))))
                1)
             (begin
               (set! /op (gethash //type_/table /token1))
               (@yy_lex)
               (set! //s (@make_assoc /op //s (@yy_term))))
             (while-loop))
            (#t #t)))
    (set! funct-result //s)
    (set! //s //s-save)
    funct-result))

(define (@yy_term)
  (let ((//s-save //s) (/op '()) (funct-result '()))
    (set! //s (@yy_factor))
    (let while-loop ()
      (cond ((= (let ((name //factor_/ops))
                  (if (vector? name)
                    (vector-ref name (- /token1 1))
                    (list-ref name (- /token1 1))))
                1)
             (begin
               (set! /op (gethash //type_/table /token1))
               (@yy_lex)
               (set! //s (@make_assoc /op //s (@yy_factor))))
             (while-loop))
            (#t #t)))
    (set! funct-result //s)
    (set! //s //s-save)
    funct-result))

(define (@yy_factor)
  (let ((//s-save //s) (funct-result '()))
    (set! //s '())
    (cond ((= /token1 //s_/m/i/n/u/s)
           (@yy_lex)
           (set! //s
             (@make //t_/negate '() (list (@yy_factor)))))
          ((= /token1 //s_/p/l/u/s)
           (@yy_lex)
           (set! //s (@yy_factor)))
          (#t (set! //s (@yy_true_factor))))
    (set! funct-result //s)
    (set! //s //s-save)
    funct-result))

(define (@yy_true_factor)
  (let ((//s-save //s) (funct-result '()))
    (set! //s (@yy_exp_atom))
    (let while-loop ()
      (cond ((= /token1 //s_/e/x/p/o/n/e/n/t)
             (begin
               (@yy_lex)
               (set! //s
                 (@make //t_/exponent '() (list //s (@yy_factor)))))
             (while-loop))
            (#t #t)))
    (set! funct-result //s)
    (set! //s //s-save)
    funct-result))

(define (@yy_exp_atom)
  (let ((//s-save //s) (/temp '()) (funct-result '()))
    (set! //s '())
    (cond ((= /token1 //s_/n/u/m/b/e/r)
           (set! //s (@make //t_/number /token2 '()))
           (@yy_lex))
          ((= (let ((name /a_prefix_ops))
                (if (vector? name)
                  (vector-ref name (- /token1 1))
                  (list-ref name (- /token1 1))))
              1)
           (set! //s (@yy_a_prefix_op)))
          ((= /token1 //s_/m/i/n/u/s)
           (@yy_lex)
           (set! //s
             (@make //t_/negate '() (list (@yy_exp_atom)))))
          ((= /token1 //s_/l/p/a/r/e/n)
           (@yy_lex)
           (set! //s (@yy_a_expression))
           (cond ((not (= /token1 //s_/r/p/a/r/e/n))
                  (@syntax_error "Missing ``)''"))
                 (#t (@yy_lex))))
          (#t (set! //s (@yy_gen_exp_atom))))
    (set! //s (@yy_checkfor_aref //s))
    (set! funct-result //s)
    (set! //s //s-save)
    funct-result))

(define (@yy_a_prefix_op)
  (let ((/type (gethash //type_/table /token1))
        (/args '()))
    (@yy_lex)
    (@yy_skip_symbol
      //s_/l/p/a/r/e/n
      "Missing `(' or argument")
    (cond ((= /type //t_/length)
           (set! /args (list (@yy_s_expression))))
          ((or (= /type //t_/abs)
               (= /type //t_/int)
               (= /type //t_/frac)
               (= /type //t_/sgn)
               (= /type //t_/slength)
               (= /type //t_/address_/of))
           (set! /args (list (@yy_a_expression))))
          ((= /type //t_/index)
           (set! /args (list (@yy_expressions))))
          (#t (set! /args (@cs (@yy_expressions)))))
    (@yy_skip_symbol //s_/r/p/a/r/e/n "Missing `)'")
    (@make /type '() /args)))

(define (@new_yy_a_prefix_op)
  (let ((/type (gethash //type_/table /token1))
        (/arg '()))
    (@yy_lex)
    (@yy_skip_symbol
      //s_/l/p/a/r/e/n
      "Missing `(' or argument")
    (cond ((or (= /type //t_/abs)
               (= /type //t_/int)
               (= /type //t_/frac))
           (set! /arg (@yy_a_expression)))
          (#t (set! /arg (@yy_s_expression))))
    (@yy_skip_symbol //s_/r/p/a/r/e/n "Missing `)'")
    (@make /type '() (list /arg))))

(define (@yy_gen_exp_atom)
  (let ((//s-save //s) (funct-result '()))
    (set! //s '())
    (cond ((= /token1 //s_/s/t/r/i/n/g)
           (set! //s (@make //t_/string /token2 '()))
           (@yy_lex))
          ((= /token1 //s_/i/d/e/n/t/i/f/i/e/r)
           (cond ((equal? (car (@yy_look)) //s_/l/p/a/r/e/n)
                  (set! //s (@yy_funct_call)))
                 (#t
                  (set! //s
                    (@make //t_/variable (@make_name /token2) '()))
                  (@yy_lex))))
          ((= /token1 //s_/h/a/s/h_/t/a/b/l/e)
           (set! //s (@make //t_/hash_/table '() '()))
           (@yy_lex))
          ((= /token1 //s_/m/e/m) (set! //s (@yy_mem_ref)))
          ((= /token1 //s_/a/t)
           (set! //s (@yy_mw_funct_call)))
          ((= /token1 //s_/p/l/i/n/k_/x/f)
           (set! //s (@yy_x_funct_call)))
          ((= /token1 //s_/i/f)
           (set! //s (@yy_if_expression)))
          ((or (= /token1 //s_/e/x/p/n_/p/l/a/c/e)
               (= /token1 //s_/v/a/r_/p/l/a/c/e))
           (set! //s
             (@make (gethash //type_/table /token1) '() '()))
           (@yy_lex))
          ((= (let ((name /g_prefix_ops))
                (if (vector? name)
                  (vector-ref name (- /token1 1))
                  (list-ref name (- /token1 1))))
              1)
           (set! //s (@yy_gen_prefix_op)))
          ((= (let ((name /numb_types))
                (if (vector? name)
                  (vector-ref name (- /token1 1))
                  (list-ref name (- /token1 1))))
              1)
           (set! //s (@yy_trivial)))
          ((= (let ((name //patterns))
                (if (vector? name)
                  (vector-ref name (- /token1 1))
                  (list-ref name (- /token1 1))))
              1)
           (set! //s (@yy_exp_pattern)))
          (#t
           (@syntax_error
             "Missing expression or operator type mismatch")
           (set! //s (@make //t_/expn_/place '() '()))))
    (set! //s (@yy_checkfor_aref //s))
    (let while-loop ()
      (cond ((= /token1 //s_/c/a/r/e/t)
             (begin
               (@yy_lex)
               (cond ((= /token1 //s_/c/a/r/e/t)
                      (@yy_lex)
                      (set! //s
                        (@make //t_/get
                               '()
                               (list //s (@yy_s_expression)))))
                     (#t
                      (set! //s (@make_get_n //s (@yy_a_expression))))))
             (while-loop))
            (#t #t)))
    (set! funct-result //s)
    (set! //s //s-save)
    funct-result))

(define (@make_get_n //i /exp)
  (if (= (@st /exp) //t_/get_n)
    (@make //t_/get_n
           '()
           (list (@make_get_n //i (list-ref /exp (+ 1 1)))
                 (list-ref /exp (+ 1 2))))
    (@make //t_/get_n '() (list //i /exp))))

(define (@yy_checkfor_aref /e)
  (let ((//s-save //s) (funct-result '()))
    (set! //s /e)
    (set! /fl_flag1 0)
    (let while-loop ()
      (cond ((= /fl_flag1 0)
             (cond ((= /token1 //s_/f/u/l/l/s/t/o/p)
                    (cond ((not (or (equal?
                                      (car (@yy_look))
                                      //s_/i/d/e/n/t/i/f/i/e/r)
                                    (equal? (car (@yy_look)) //s_/l/p/a/r/e/n)))
                           (set! /fl_flag1 1))
                          (#t
                           (set! //s (@yy_struct_ref //s))
                           (set! /fl_flag1 0))))
                   ((= /token1 //s_/l/b/r/a/c/k/e/t)
                    (set! //s (@yy_array_ref //s))
                    (set! /fl_flag1 0))
                   ((= /token1 //s_/p/r/i/m/e)
                    (set! //s (@make //t_/primed_/var (@v //s) '()))
                    (@yy_lex)
                    (set! /fl_flag1 1))
                   (#t (set! /fl_flag1 1)))
             (while-loop))
            (#t #t)))
    (set! funct-result //s)
    (set! //s //s-save)
    funct-result))

(define (@yy_struct_ref /e)
  (let ((/temp '())
        (/name '())
        (//s-save //s)
        (funct-result '()))
    (set! //s '())
    (@yy_lex)
    (cond ((= /token1 //s_/l/p/a/r/e/n)
           (@yy_lex)
           (set! /temp (@yy_expression))
           (@yy_skip_symbol
             //s_/r/p/a/r/e/n
             "Missing `)' in `Gethash'")
           (set! //s
             (@make //t_/gethash '() (list /e /temp))))
          (#t
           (set! /name (@make_name /token2))
           (@yy_lex)
           (set! //s
             (@make //t_/struct
                    '()
                    (list (@make //t_/name /name '()) /e)))))
    (set! funct-result //s)
    (set! //s //s-save)
    funct-result))

(define (@yy_array_ref /e)
  (let ((/exps '())
        (//s-save //s)
        (/type '())
        (funct-result '()))
    (set! //s '())
    (@yy_lex)
    (set! /exps (list (@yy_expression)))
    (cond ((= /token1 //s_/r/b/r/a/c/k/e/t)
           (set! /type //t_/aref)
           (set! /exps
             (list (@make //t_/expressions '() /exps))))
          ((= /token1 //s_/c/o/m/m/a)
           (set! /type //t_/rel_/seg)
           (@yy_lex)
           (set! /exps
             (concat /exps (list (@yy_expression)))))
          ((= /token1 //s_/d/o/t/d/o/t)
           (@yy_lex)
           (cond ((= /token1 //s_/r/b/r/a/c/k/e/t)
                  (set! /type //t_/final_/seg))
                 (#t
                  (set! /type //t_/sub_/seg)
                  (set! /exps
                    (concat /exps (list (@yy_expression)))))))
          (#t
           (@syntax_error "Malformed array subscript")
           (set! /type //t_/aref)))
    (@yy_skip_symbol
      //s_/r/b/r/a/c/k/e/t
      "Missing `]' in array reference")
    (set! /exps (cons /e /exps))
    (set! funct-result (@make /type '() /exps))
    (set! //s //s-save)
    funct-result))

(define (@yy_mem_ref)
  (let ((/exps '())
        (//s-save //s)
        (/type '())
        (funct-result '()))
    (set! //s '())
    (@yy_lex)
    (set! /exps (list (@yy_expression)))
    (cond ((= /token1 //s_/r/b/r/a/c/k/e/t)
           (set! /type //t_/mem))
          ((= /token1 //s_/c/o/m/m/a)
           (set! /type //t_/mem_/rel)
           (@yy_lex)
           (set! /exps
             (concat /exps (list (@yy_expression)))))
          ((= /token1 //s_/d/o/t/d/o/t)
           (@yy_lex)
           (cond ((= /token1 //s_/r/b/r/a/c/k/e/t)
                  (@syntax_error "Malformed memory segment"))
                 (#t
                  (set! /type //t_/mem_/seg)
                  (set! /exps
                    (concat /exps (list (@yy_expression)))))))
          (#t
           (@syntax_error "Malformed array subscript")
           (set! /type //t_/aref)))
    (@yy_skip_symbol
      //s_/r/b/r/a/c/k/e/t
      "Missing `]' in memory reference")
    (set! funct-result (@make /type '() /exps))
    (set! //s //s-save)
    funct-result))

(define (@yy_funct_call)
  (let ((/name (@make_name /token2)) (/args '()))
    (@yy_lex)
    (@yy_skip_symbol
      //s_/l/p/a/r/e/n
      "Missing `(' or argument list in function call")
    (cond ((not (= /token1 //s_/r/p/a/r/e/n))
           (set! /args (@yy_expressions)))
          (#t
           (set! /args (@make //t_/expressions '() '()))))
    (@yy_skip_symbol //s_/r/p/a/r/e/n "Missing `)'")
    (@make //t_/funct_/call
           '()
           (list (@make //t_/name /name '()) /args))))

(define (@yy_mw_funct_call)
  (let ((/name '()) (/args '()))
    (set! /name
      (@make_name (string-append "@" /token2)))
    (@yy_lex)
    (cond ((= /token1 //s_/l/p/a/r/e/n)
           (@yy_lex)
           (cond ((= /token1 //s_/r/p/a/r/e/n)
                  (set! /args (@make //t_/expressions '() '())))
                 (#t (set! /args (@yy_expressions))))
           (@yy_skip_symbol
             //s_/r/p/a/r/e/n
             "Missing `)' in MW_Funct call"))
          (#t
           (set! /args (@make //t_/expressions '() '()))))
    (@make //t_/m/w_/funct_/call
           '()
           (list (@make //t_/name /name '()) /args))))

(define (@yy_x_funct_call)
  (let ((/name '()) (/args '()))
    (@yy_lex)
    (set! /name (@yy_name "!XF call"))
    (@yy_skip_symbol
      //s_/l/p/a/r/e/n
      "Missing `(' or argument list")
    (cond ((not (= /token1 //s_/r/p/a/r/e/n))
           (set! /args (@yy_expressions)))
          (#t
           (set! /args (@make //t_/expressions '() '()))))
    (@yy_skip_symbol //s_/r/p/a/r/e/n "Missing `)'")
    (set! //s
      (@make //t_/x_/funct_/call
             '()
             (list /name /args)))
    //s))

(define (@yy_if_expression)
  (let ((/cond '()) (/then '()) (/else '()))
    (@yy_lex)
    (set! /cond (@yy_condition))
    (@yy_skip_symbol //s_/t/h/e/n "Missing `THEN'")
    (set! /then (@yy_expression))
    (@yy_skip_symbol //s_/e/l/s/e "Missing `ELSE'")
    (set! /else (@yy_expression))
    (@yy_skip_symbol //s_/f/i "Missing `FI'")
    (@make //t_/if '() (list /cond /then /else))))

(define (@yy_gen_prefix_op)
  (let ((/type (gethash //type_/table /token1))
        (/name '())
        (/args '()))
    (@yy_lex)
    (@yy_skip_symbol
      //s_/l/p/a/r/e/n
      "Missing `(' or argument(s)")
    (cond ((= /type //t_/substr)
           (set! /args (list (@yy_expressions))))
          ((or (= /type //t_/reduce) (= /type //t_/map))
           (cond ((not (= /token1 //s_/s/t/r/i/n/g))
                  (@syntax_error
                    "Missing string argument in MAP/REDUCE")
                  (set! /args
                    (list (@name (@make_name "_Missing_")))))
                 (#t
                  (set! /args (list (@name (@make_name /token2))))
                  (@yy_lex)
                  (@yy_skip_symbol
                    //s_/c/o/m/m/a
                    "Missing `,' or 2nd argument in MAP/REDUCE")))
           (set! /args
             (concat /args (list (@yy_s_expression)))))
          (#t (set! /args (list (@yy_s_expression)))))
    (@yy_skip_symbol //s_/r/p/a/r/e/n "Missing `)'")
    (@make /type '() /args)))

(define (@yy_exp_pattern)
  (let ((/type /token1)
        (/stype /token2)
        (/name '())
        (//s-save //s)
        (/comps '())
        (funct-result '()))
    (set! //s '())
    (let ((/-result-
            (@yy_parse_pattern /type /name /comps)))
      (set! /name (car /-result-))
      (set! /-result- (cdr /-result-))
      (set! /comps (car /-result-))
      (set! /-result- (cdr /-result-)))
    (set! //s
      (@make (gethash
               /pattern_type
               (list //t_/expression /type))
             /name
             /comps))
    (set! funct-result //s)
    (set! //s //s-save)
    funct-result))

(define (@yy_s_expression)
  (let ((//s-save //s) (/op '()) (funct-result '()))
    (set! //s '())
    (set! //s (@yy_s_term))
    (let while-loop ()
      (cond ((= (let ((name //s_/term_/ops))
                  (if (vector? name)
                    (vector-ref name (- /token1 1))
                    (list-ref name (- /token1 1))))
                1)
             (begin
               (set! /op (gethash //type_/table /token1))
               (@yy_lex)
               (set! //s
                 (@make /op '() (list //s (@yy_s_term)))))
             (while-loop))
            (#t #t)))
    (set! funct-result //s)
    (set! //s //s-save)
    funct-result))

(define (@yy_s_term)
  (let ((//s-save //s) (/op '()) (funct-result '()))
    (set! //s (@yy_s_factor))
    (let while-loop ()
      (cond ((= (let ((name //s_/factor_/ops))
                  (if (vector? name)
                    (vector-ref name (- /token1 1))
                    (list-ref name (- /token1 1))))
                1)
             (begin
               (set! /op (gethash //type_/table /token1))
               (@yy_lex)
               (set! //s
                 (@make /op '() (list //s (@yy_s_factor)))))
             (while-loop))
            (#t #t)))
    (set! funct-result //s)
    (set! //s //s-save)
    funct-result))

(define (@yy_s_factor)
  (let ((//s-save //s) (/op '()) (funct-result '()))
    (set! //s (@yy_s_atom))
    (let while-loop ()
      (cond ((= (let ((name //s_/atom_/ops))
                  (if (vector? name)
                    (vector-ref name (- /token1 1))
                    (list-ref name (- /token1 1))))
                1)
             (begin
               (set! /op (gethash //type_/table /token1))
               (@yy_lex)
               (set! //s
                 (@make /op '() (list //s (@yy_s_atom)))))
             (while-loop))
            (#t #t)))
    (set! funct-result //s)
    (set! //s //s-save)
    funct-result))

(define (@yy_s_atom)
  (let ((//s-save //s) (funct-result '()))
    (set! //s '())
    (cond ((= /token1 //s_/l/b/r/a/c/e)
           (set! //s (@yy_set)))
          ((= /token1 //s_/l/p/a/r/e/n)
           (@yy_lex)
           (set! //s (@yy_s_expression))
           (cond ((not (= /token1 //s_/r/p/a/r/e/n))
                  (@syntax_error "Missing `)'"))
                 (#t (@yy_lex))))
          ((= /token1 //s_/l/a/n/g/l/e)
           (@yy_lex)
           (cond ((= /token1 //s_/r/a/n/g/l/e)
                  (set! //s
                    (@make //t_/sequence
                           '()
                           (list (@make //t_/expressions '() '()))))
                  (@yy_lex))
                 (#t (set! //s (@yy_sequence)))))
          ((= /token1 //s_/a/r/r/a/y)
           (set! //s (@yy_array)))
          ((= (let ((name /s_prefix_ops))
                (if (vector? name)
                  (vector-ref name (- /token1 1))
                  (list-ref name (- /token1 1))))
              1)
           (set! //s (@yy_gen_prefix_op)))
          (#t (set! //s (@yy_gen_exp_atom))))
    (set! //s (@yy_checkfor_aref //s))
    (set! funct-result //s)
    (set! //s //s-save)
    funct-result))

(define (@yy_set)
  (let ((/exp '()) (/cond '()))
    (@yy_lex)
    (set! /exp (@yy_expression))
    (@yy_skip_symbol
      //s_/v/b/a/r
      "Missing `|' in SET")
    (set! /cond (@yy_condition))
    (@yy_skip_symbol
      //s_/r/b/r/a/c/e
      "Missing `}' after SET")
    (@make //t_/set '() (list /exp /cond))))

(define (@yy_sequence)
  (let ((//s-save //s) (funct-result '()))
    (set! //s (@yy_expressions))
    (@yy_skip_symbol
      //s_/r/a/n/g/l/e
      "Missing `>' at end of sequence")
    (set! funct-result
      (@make //t_/sequence '() (list //s)))
    (set! //s //s-save)
    funct-result))

(define (@yy_array)
  (let ((/len '()) (/val '()))
    (@yy_lex)
    (@yy_skip_symbol
      //s_/l/p/a/r/e/n
      "Missing `(' in `ARRAY'")
    (set! /len (@yy_a_expression))
    (@yy_skip_symbol
      //s_/c/o/m/m/a
      "Missing `,' or 2nd argument in `ARRAY'")
    (set! /val (@yy_expression))
    (@yy_skip_symbol
      //s_/r/p/a/r/e/n
      "Missing `)' or malformaed expression in `ARRAY'")
    (@make //t_/array '() (list /len /val))))

(define (@yy_expressions)
  (let ((//s-save //s) (funct-result '()))
    (set! //s (list (@yy_expression)))
    (let while-loop ()
      (cond ((= /token1 //s_/c/o/m/m/a)
             (begin
               (@yy_lex)
               (set! //s (cons (@yy_expression) //s)))
             (while-loop))
            (#t #t)))
    (set! funct-result
      (@make //t_/expressions '() (reverse //s)))
    (set! //s //s-save)
    funct-result))

(define (@yy_fill)
  (let ((//s-save //s) (funct-result '()))
    (set! //s '())
    (@yy_lex)
    (cond ((= /token1 //s_/s/t/a/t/e/m/e/n/t)
           (set! //s
             (@yy_fill_s //t_/statement //t_/fill_/stat)))
          ((= /token1 //s_/s/t/a/t/e/m/e/n/t/s)
           (set! //s
             (@yy_fill_s //t_/statements //t_/fill_/stats)))
          ((= /token1 //s_/e/x/p/r/e/s/s/i/o/n)
           (set! //s
             (@yy_fill_s //t_/expression //t_/fill_/expn)))
          ((= /token1 //s_/e/x/p/r/e/s/s/i/o/n/s)
           (set! //s
             (@yy_fill_s //t_/expressions //t_/fill_/expns)))
          ((= /token1 //s_/c/o/n/d/i/t/i/o/n)
           (set! //s
             (@yy_fill_s //t_/condition //t_/fill_/cond)))
          ((= /token1 //s_/d/e/f/i/n/i/t/i/o/n)
           (set! //s
             (@yy_fill_s //t_/definition //t_/fill_/defn)))
          ((= /token1 //s_/d/e/f/i/n/i/t/i/o/n/s)
           (set! //s
             (@yy_fill_s //t_/definitions //t_/fill_/defns)))
          ((= /token1 //s_/l/v/a/l/u/e)
           (set! //s
             (@yy_fill_s //t_/lvalue //t_/fill_/lvalue)))
          ((= /token1 //s_/l/v/a/l/u/e/s)
           (set! //s
             (@yy_fill_s //t_/lvalues //t_/fill_/lvalues)))
          ((= /token1 //s_/a/s/s/i/g/n)
           (set! //s
             (@yy_fill_s //t_/assign //t_/fill_/assign)))
          ((= /token1 //s_/a/s/s/i/g/n/s)
           (set! //s
             (@yy_fill_s //t_/assigns //t_/fill_/assigns)))
          ((= /token1 //s_/g/u/a/r/d/e/d)
           (set! //s
             (@yy_fill_s //t_/guarded //t_/fill_/guarded)))
          ((= /token1 //s_/a/c/t/i/o/n)
           (set! //s
             (@yy_fill_s //t_/action //t_/fill_/action)))
          (#t
           (@syntax_error
             "Incorrect type specified for FILL")
           (let while-loop ()
             (cond ((not (= /token1 //s_/e/n/d/f/i/l/l))
                    (@yy_lex)
                    (while-loop))
                   (#t #t)))
           (set! //s (@make //t_/expn_/place '() '()))))
    (@yy_skip_symbol
      //s_/e/n/d/f/i/l/l
      "Missing `ENDFILL'")
    (set! funct-result //s)
    (set! //s //s-save)
    funct-result))

(define (@yy_fill_s //g/t /result_type)
  (let ((//s-save //s) (funct-result '()))
    (set! //s '())
    (@yy_lex)
    (set! //s (@yy_parse //g/t))
    (set! funct-result
      (@make /result_type '() (list //s)))
    (set! //s //s-save)
    funct-result))

