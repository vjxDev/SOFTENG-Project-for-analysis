(define /%const__adt-procs__1
  (@make 108 '() '()))

(define (@equal? //i1 //i2)
  (let ((//o/k 1))
    (cond ((eq? //i1 //i2) (set! //o/k 1))
          ((or (null? //i1) (null? //i2)) (set! //o/k 0))
          ((@equal_items? //i1 //i2) (set! //o/k 1))
          (#t (set! //o/k 0)))
    (= //o/k 1)))

(define (@equal_items? //i1 //i2)
  (let ((//o/k 1))
    (cond ((not (= (@st //i1) (@st //i2))) (set! //o/k 0))
          ((@has_value_type? (@st //i1))
           (cond ((not (equal? (@v //i1) (@v //i2)))
                  (set! //o/k 0))))
          ((not (= (@size //i1) (@size //i2)))
           (set! //o/k 0))
          (#t
           (let ((//c1 (@cs //i1)) (//c2 (@cs //i2)))
             (let while-loop ()
               (cond ((and (= //o/k 1) (not (null? //c1)))
                      (cond ((not (@equal_items? (car //c1) (car //c2)))
                             (set! //o/k 0))
                            (#t
                             (set! //c1 (cdr //c1))
                             (set! //c2 (cdr //c2))))
                      (while-loop))
                     (#t #t))))))
    (= //o/k 1)))

(define (@seq_equal? //l1 //l2)
  (let ((//o/k 1))
    (cond ((not (= (if (vector? //l1)
                     (vector-length //l1)
                     (length //l1))
                   (if (vector? //l2)
                     (vector-length //l2)
                     (length //l2))))
           (set! //o/k 0))
          (#t
           (let while-loop ()
             (cond ((and (= //o/k 1) (not (null? //l1)))
                    (cond ((not (@equal_items? (car //l1) (car //l2)))
                           (set! //o/k 0))
                          (#t
                           (set! //l1 (cdr //l1))
                           (set! //l2 (cdr //l2))))
                    (while-loop))
                   (#t #t)))))
    (= //o/k 1)))

(define (@lr_equal? //i1 //i2)
  (let ((//o/k 1))
    (cond ((and (not (= (@st //i1) (@st //i2)))
                (not (and (= (@gt //i1) //t_/lvalue)
                          (= (@var_to_expn_type (@st //i1)) (@st //i2))))
                (not (and (= (@gt //i2) //t_/lvalue)
                          (= (@var_to_expn_type (@st //i2)) (@st //i1)))))
           (set! //o/k 0))
          ((@has_value_type? (@st //i1))
           (cond ((not (equal? (@v //i1) (@v //i2)))
                  (set! //o/k 0))))
          ((not (= (@size //i1) (@size //i2)))
           (set! //o/k 0))
          (#t
           (let ((//c1 (@cs //i1)) (//c2 (@cs //i2)))
             (let while-loop ()
               (cond ((and (= //o/k 1) (not (null? //c1)))
                      (cond ((not (@lr_equal? (car //c1) (car //c2)))
                             (set! //o/k 0))
                            (#t
                             (set! //c1 (cdr //c1))
                             (set! //c2 (cdr //c2))))
                      (while-loop))
                     (#t #t))))))
    (= //o/k 1)))

(define (@lr_seq_equal? //l1 //l2)
  (let ((//o/k 1))
    (cond ((not (= (if (vector? //l1)
                     (vector-length //l1)
                     (length //l1))
                   (if (vector? //l2)
                     (vector-length //l2)
                     (length //l2))))
           (set! //o/k 0))
          (#t
           (let while-loop ()
             (cond ((and (= //o/k 1) (not (null? //l1)))
                    (cond ((not (@lr_equal? (car //l1) (car //l2)))
                           (set! //o/k 0))
                          (#t
                           (set! //l1 (cdr //l1))
                           (set! //l2 (cdr //l2))))
                    (while-loop))
                   (#t #t)))))
    (= //o/k 1)))

(define (@increment //i //a-par /inc /tv)
  (let ((//a-save //a) (//r '()) (funct-result '()))
    (set! //a //a-par)
    (cond ((= (@st //i) //t_/exit)
           (cond ((>= (@v //i) /tv)
                  (cond ((<= (+ (@v //i) /inc) 0)
                         (set! //r (list (@make //t_/skip '() '()))))
                        (#t
                         (set! //r
                           (list (@make //t_/exit (+ (@v //i) /inc) '()))))))
                 (#t (set! //r (list //i)))))
          ((= (@st //i) //t_/skip)
           (cond ((and (> /inc 0) (= /tv 0))
                  (set! //r (list (@make //t_/exit /inc '()))))
                 (#t (set! //r (list //i)))))
          ((and (= (@st //i) //t_/call) (equal? //a "Reg"))
           (set! //r (list //i)))
          ((@simple? //i)
           (cond ((= /tv 0)
                  (cond ((<= /inc 0)
                         (set! //r (list //i (@make //t_/skip '() '()))))
                        (#t
                         (set! //r (list //i (@make //t_/exit /inc '()))))))
                 (#t (set! //r (list //i)))))
          ((= (@gt //i) //t_/statements)
           (set! //r
             (@make //t_/statements
                    '()
                    (@increment_list (@cs //i) //a /inc /tv))))
          ((= (@st //i) //t_/floop)
           (set! //r
             (list (@make //t_/floop
                          '()
                          (list (@increment
                                  (list-ref //i (+ 1 1))
                                  //a
                                  /inc
                                  (+ /tv 1)))))))
          ((@has_comps_type? (@st //i))
           (let ((/comp '()))
             (let ((var-save /comp) (seq-save (@cs //i)))
               (if (vector? seq-save)
                 (set! seq-save (vector-elts seq-save)))
               (let for-in-loop ((for-tmp seq-save))
                 (cond ((not (null? for-tmp))
                        (set! /comp (car for-tmp))
                        (set! //r
                          (cons (@increment /comp //a /inc /tv) //r))
                        (for-in-loop (cdr for-tmp)))
                       (#t #t)))
               (set! /comp var-save))
             (cond ((= (@gt //i) //t_/statement)
                    (set! //r
                      (list (@make (@st //i) '() (reverse //r)))))
                   (#t
                    (set! //r (@make (@st //i) '() (reverse //r)))))))
          (#t (set! //r //i)))
    (set! funct-result //r)
    (set! //a //a-save)
    funct-result))

(define (@increment_list //l //a-par /inc /tv)
  (let ((//a-save //a)
        (//result '())
        (//term_/v /tv)
        (funct-result '()))
    (set! //a //a-par)
    (cond ((and (= /tv 0)
                (> (if (vector? //l)
                     (vector-length //l)
                     (length //l))
                   1))
           (set! //term_/v 1)))
    (cond ((null? //l) #t)
          ((@gen_improper? (car //l) //a)
           (set! //result
             (concat
               (@increment (car //l) //a /inc //term_/v)
               (cdr //l))))
          (#t
           (set! //result
             (concat
               (@increment (car //l) //a /inc //term_/v)
               (@increment_list (cdr //l) //a /inc /tv)))))
    (set! funct-result //result)
    (set! //a //a-save)
    funct-result))

(define (@incremented_equal? //s //i)
  (let ((/i-save /i) (funct-result '()))
    (set! /i (- 1))
    (set! /i (@i_eq //s //i (@as_type) /i))
    (set! funct-result (>= /i 0))
    (set! /i /i-save)
    funct-result))

(define (@i_eq //s //i //a-par /i-par)
  (let ((/i-save /i) (//a-save //a) (funct-result '()))
    (set! /i /i-par)
    (set! //a //a-par)
    (cond ((and (= (@st //s) //t_/statements)
                (= (@st //i) //t_/statements))
           (@i_eq_stats (@cs //s) (@cs //i)))
          ((or (not (= (@st //s) (@st //i)))
               (not (= (@size //s) (@size //i))))
           (set! /i (- 2)))
          (#t
           (cond ((and (@simple? //s) (@simple? //i))
                  (cond ((= (@st //s) //t_/exit)
                         (cond ((and (>= /i 0) (= (+ (@v //s) /i) (@v //i))) #t)
                               ((and (equal? /i (- 1)) (>= (@v //i) (@v //s)))
                                (set! /i (- (@v //i) (@v //s))))
                               (#t (set! /i (- 2)))))
                        ((or (> /i 0) (not (@equal_items? //s //i)))
                         (set! /i (- 2)))))
                 (#t
                  (let ((//s (@cs //s)) (//i (@cs //i)))
                    (let while-loop ()
                      (cond ((and (not (equal? /i (- 2))) (not (null? //s)))
                             (begin
                               (set! /i (@i_eq (car //s) (car //i) //a /i))
                               (set! //s (cdr //s))
                               (set! //i (cdr //i)))
                             (while-loop))
                            (#t #t))))))))
    (set! funct-result /i)
    (set! /i /i-save)
    (set! //a //a-save)
    funct-result))

(define (@i_eq_stats //s //i)
  (cond ((null? //s)
         (cond ((null? //i)
                (cond ((or (= /i 0) (equal? /i (- 1))) (set! /i 0))
                      (#t (set! /i (- 2)))))
               ((and (>= /i 0)
                     (= (if (vector? //i)
                          (vector-length //i)
                          (length //i))
                        1)
                     (= (@st (car //i)) //t_/exit)
                     (equal? (@v (car //i)) /i))
                #t)
               ((and (equal? /i (- 1))
                     (= (if (vector? //i)
                          (vector-length //i)
                          (length //i))
                        1)
                     (= (@st (car //i)) //t_/exit))
                (set! /i (@v (car //i))))
               (#t (set! /i (- 2)))))
        ((null? //i) (set! /i (- 2)))
        (#t
         (set! /i (@i_eq (car //s) (car //i) //a /i))
         (cond ((not (@gen_improper? (car //s) //a))
                (@i_eq_stats (cdr //s) (cdr //i)))))))

(define (@syntax_ok? //item) (@s_ok? //item '()))

(define (@s_ok? //item //posn)
  (let ((//o/k 1)
        (//c '())
        (//s/t (@st //item))
        (//s '())
        (//l 0)
        (/i-save /i)
        (funct-result '()))
    (set! /i 1)
    (cond ((@has_value_type? //s/t) #t)
          (#t
           (set! //c (@cs //item))
           (set! //s (@syntax //s/t))
           (cond ((@list_type? //s/t) (set! //l 1))
                 ((not (= (if (vector? //s)
                            (vector-length //s)
                            (length //s))
                          (if (vector? //c)
                            (vector-length //c)
                            (length //c))))
                  (begin
                    (display "Bad length at ")
                    (begin
                      (display (reverse //posn))
                      (begin
                        (display " Type ")
                        (begin (display //s/t) (newline) (force-output)))))
                  (begin
                    (display "Length = ")
                    (begin
                      (display //c)
                      (begin
                        (display " should be: ")
                        (begin (display //s) (newline) (force-output)))))
                  (set! //o/k 0)))
           (let while-loop ()
             (cond ((and (= //o/k 1) (not (null? //c)))
                    (begin
                      (cond ((not (= (@gt (car //c)) (car //s)))
                             (@print_wsl //item "")
                             (begin
                               (display "Bad type at ")
                               (begin
                                 (display (reverse (cons /i //posn)))
                                 (newline)
                                 (force-output)))
                             (begin
                               (display "Gen type is: ")
                               (begin
                                 (display (@type_name (@gt (car //c))))
                                 (begin
                                   (display "(")
                                   (begin
                                     (display (@gt (car //c)))
                                     (begin
                                       (display ")  Should be: ")
                                       (begin
                                         (display (@type_name (car //s)))
                                         (begin
                                           (display "(")
                                           (begin
                                             (display (car //s))
                                             (begin
                                               (display ")")
                                               (newline)
                                               (force-output))))))))))
                             (set! //o/k 0))
                            ((not (@s_ok? (car //c) (cons /i //posn)))
                             (set! //o/k 0)))
                      (cond ((= //l 0) (set! //s (cdr //s))))
                      (set! //c (cdr //c))
                      (set! /i (+ /i 1)))
                    (while-loop))
                   (#t #t)))))
    (set! funct-result (= //o/k 1))
    (set! /i /i-save)
    funct-result))

(define (@clever_delete) (@delete) (@fixup))

(define (@fixup)
  (cond ((@up?)
         (let ((//g (@gt (@parent))) (//s (@st (@parent))))
           (cond ((= //g //t_/statement)
                  (cond ((= //s //t_/cond) (@fixup_cond))
                        ((or (and (not (@list_type? //s))
                                  (not (= (@size (@parent))
                                          (if (vector? (@syntax //s))
                                            (vector-length (@syntax //s))
                                            (length (@syntax //s))))))
                             (not (@cs? (@parent))))
                         (@up)
                         (@fixup_statement //s))))
                 ((= //g //t_/statements)
                  (cond ((not (@cs? (@parent)))
                         (@up)
                         (cond ((@up?) (@clever_delete))
                               (#t (@paste_over (@skips)))))))
                 ((= //g //t_/definition)
                  (cond ((and (= //s //t_/proc) (< (@size (@parent)) 4))
                         (@to_last)
                         (@paste_after (@skips))
                         (@right))
                        ((and (or (= //s //t_/funct) (= //s //t_/b/funct))
                              (< (@size (@parent)) 5))
                         (@to_last)
                         (@paste_before (@skips))
                         (@right))))
                 ((= //g //t_/definitions)
                  (cond ((not (@cs? (@parent)))
                         (@up)
                         (@up)
                         (@splice_over (@cs (list-ref (@i) (+ 1 1)))))))
                 ((= //g //t_/guarded)
                  (cond ((< (@size (@parent)) 2)
                         (@up)
                         (cond ((= (@st (@parent)) //t_/cond)
                                (let ((//p (@posn))
                                      (//c (@not (list-ref (@i) (+ 1 1)))))
                                  (let while-loop ()
                                    (cond ((@right?)
                                           (begin
                                             (@right)
                                             (@down)
                                             (@paste_over (@and //c (@i)))
                                             (@up))
                                           (while-loop))
                                          (#t #t)))
                                  (@goto //p)
                                  (@clever_delete)))
                               (#t (@down) (@paste_after (@skips)) (@up))))))
                 ((= //g //t_/action)
                  (cond ((and (= (@size (@parent)) 1)
                              (= (@st (list-ref (@parent) (+ 1 1))) //t_/name))
                         (@to 1)
                         (@paste_after (@skips)))))
                 ((member
                    //g
                    (list //t_/expression
                          //t_/expressions
                          //t_/condition
                          //t_/lvalue
                          //t_/lvalues
                          //t_/assign
                          //t_/assigns))
                  #t)))
         (let while-loop ()
           (cond ((and (@up?)
                       (> (@posn_n) (@size (@parent)))
                       (@left?))
                  (@left)
                  (while-loop))
                 (#t #t)))
         (let while-loop ()
           (cond ((and (@up?)
                       (> (@posn_n) (@size (@parent)))
                       (@up?))
                  (@up)
                  (while-loop))
                 (#t #t))))))

(define (@fixup_statement //s/t)
  (cond ((= //s/t //t_/while)
         (@paste_over
           (@make //t_/assert
                  '()
                  (list (@not (list-ref (@i) (+ 1 1)))))))
        ((or (= //s/t //t_/d_/if) (= //s/t //t_/floop))
         (@paste_over /%const__adt-procs__1))
        ((= //s/t //t_/join)
         (@splice_over (@cs (list-ref (@i) (+ 1 1)))))
        ((or (@ifmatch_type? //s/t)
             (= //s/t //t_/m/w_/proc))
         (@down_last)
         (@paste_after (@skips)))
        ((or (= //s/t //t_/m/w_/funct)
             (= //s/t //t_/m/w_/b/funct))
         (@down_last)
         (@paste_before (@skips)))
        (#t (@clever_delete))))

(define (@fixup_cond)
  (cond ((not (@cs? (@parent))) (@up) (@clever_delete))
        (#t
         (let ((/p (@posn_n)))
           (@up)
           (@fix_cond)
           (cond ((>= (@size (@i)) /p) (@down_to /p))
                 ((@down?) (@down)))))))

(define (@fix_cond)
  (cond ((not (@cs? (@i))) (@clever_delete))
        (#t
         (let ((/fixed (@fix_cond_item (@i))))
           (cond ((null? /fixed) (@clever_delete))
                 ((= (@st /fixed) //t_/statements)
                  (@splice_over (@cs /fixed)))
                 ((not (eq? /fixed (@i))) (@paste_over /fixed)))))))

(define (@fix_dijkstra)
  (cond ((not (@cs? (@i)))
         (cond ((= (@st (@i)) //t_/d_/if) (@delete))
               (#t (@paste_over (@make //t_/abort '() '())))))
        (#t
         (@down)
         (set! /fl_flag1 0)
         (let while-loop ()
           (cond ((= /fl_flag1 0)
                  (begin
                    (cond ((= (@size (@i)) 1)
                           (@down)
                           (@paste_after (@skips))
                           (@up))
                          ((not (@cs? (list-ref (@i) (+ 1 2))))
                           (@down_last)
                           (@paste_over (@skips))
                           (@up)))
                    (cond ((not (@right?)) (set! /fl_flag1 1))
                          (#t (@right) (set! /fl_flag1 0))))
                  (while-loop))
                 (#t #t)))
         (@up))))

