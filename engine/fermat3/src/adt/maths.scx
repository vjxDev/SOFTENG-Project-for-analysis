(define (/foreach-maths-1 //depth //a/s_/type)
  (cond ((or (= (@st (@i)) //t_/and)
             (= (@st (@i)) //t_/or))
         (@mth_duplicate_relations)))
  (cond ((= (@st (@i)) //t_/and)
         (@mth_known_value1 //budget)
         (@mth_known_value3 //budget)))
  (cond ((= (@st (@i)) //t_/or)
         (@mth_known_value2 //budget)
         (@mth_known_value4 //budget)))
  (cond ((> //budget 10) (@mth_expensive //budget)))
  (cond ((or (= (@st (@i)) //t_/forall)
             (= (@st (@i)) //t_/exists))
         (@mth_quantifiers //budget))))

(define (/foreach-maths-2 //depth //a/s_/type)
  (cond ((or (and (= (@st (@i)) //t_/and)
                  (> (@size (@i)) 1)
                  (= (@st (list-ref (@i) (+ 1 1))) //t_/or)
                  (= (@st (list-ref (@i) (+ 1 2))) //t_/or))
             (and (= (@st (@i)) //t_/or)
                  (> (@size (@i)) 1)
                  (= (@st (list-ref (@i) (+ 1 1))) //t_/and)
                  (= (@st (list-ref (@i) (+ 1 2))) //t_/and)))
         (@mth_common_components //budget))))

(define (/foreach-maths-3 //depth //a/s_/type)
  (cond ((and (@cs? (@i))
              (> (vector-ref //eval_/op (- (@st (@i)) 1)) 0)
              (@mth_constants?
                (@cs (@i))
                (vector-ref //eval_/op (- (@st (@i)) 1))))
         (set! //s/t (@st (@i)))
         (set! /v (@mth_values (@cs (@i))))
         (set! /badnum 0)
         (let ((/vv '()))
           (let ((var-save /n) (seq-save /v))
             (if (vector? seq-save)
               (set! seq-save (vector-elts seq-save)))
             (let for-in-loop ((for-tmp seq-save))
               (cond ((not (null? for-tmp))
                      (set! /n (car for-tmp))
                      (cond ((and (string? /n)
                                  (@starts_with? /n "hex 0x")
                                  (< (string-length /n) 14))
                             (set! /vv
                               (cons (@hex_to_num
                                       (let ((s /n))
                                         (substring s 6 (string-length s))))
                                     /vv)))
                            ((and (string? /n) (@starts_with? /n "hex 0x"))
                             (set! /vv (cons /n /vv))
                             (set! /badnum 1))
                            (#t (set! /vv (cons /n /vv))))
                      (for-in-loop (cdr for-tmp)))
                     (#t #t)))
             (set! /n var-save))
           (set! /v (reverse /vv)))
         (cond ((= /badnum 1) #t)
               ((= //s/t //t_/plus)
                (@paste_over
                  (@make //t_/number
                         (let ((l /v) (reduce-result '()))
                           (cond ((null? l) '())
                                 (#t
                                  (set! reduce-result (car l))
                                  (set! l (cdr l))
                                  (let while-loop ()
                                    (cond ((not (null? l))
                                           (set! reduce-result
                                             (+ reduce-result (car l)))
                                           (set! l (cdr l))
                                           (while-loop))
                                          (#t #t)))
                                  reduce-result)))
                         '())))
               ((= //s/t //t_/times)
                (@paste_over
                  (@make //t_/number
                         (let ((l /v) (reduce-result '()))
                           (cond ((null? l) '())
                                 (#t
                                  (set! reduce-result (car l))
                                  (set! l (cdr l))
                                  (let while-loop ()
                                    (cond ((not (null? l))
                                           (set! reduce-result
                                             (* reduce-result (car l)))
                                           (set! l (cdr l))
                                           (while-loop))
                                          (#t #t)))
                                  reduce-result)))
                         '())))
               ((= //s/t //t_/exponent)
                (@paste_over
                  (let ((l (@cs (@i))) (reduce-result '()))
                    (cond ((null? l) '())
                          (#t
                           (set! reduce-result (car l))
                           (set! l (cdr l))
                           (let while-loop ()
                             (cond ((not (null? l))
                                    (set! reduce-result
                                      (@mth_eval_exponent
                                        reduce-result
                                        (car l)))
                                    (set! l (cdr l))
                                    (while-loop))
                                   (#t #t)))
                           reduce-result)))))
               ((= //s/t //t_/max)
                (@paste_over
                  (@make //t_/number
                         (let ((l /v) (reduce-result '()))
                           (cond ((null? l) '())
                                 (#t
                                  (set! reduce-result (car l))
                                  (set! l (cdr l))
                                  (let while-loop ()
                                    (cond ((not (null? l))
                                           (set! reduce-result
                                             (max reduce-result (car l)))
                                           (set! l (cdr l))
                                           (while-loop))
                                          (#t #t)))
                                  reduce-result)))
                         '())))
               ((= //s/t //t_/min)
                (@paste_over
                  (@make //t_/number
                         (let ((l /v) (reduce-result '()))
                           (cond ((null? l) '())
                                 (#t
                                  (set! reduce-result (car l))
                                  (set! l (cdr l))
                                  (let while-loop ()
                                    (cond ((not (null? l))
                                           (set! reduce-result
                                             (min reduce-result (car l)))
                                           (set! l (cdr l))
                                           (while-loop))
                                          (#t #t)))
                                  reduce-result)))
                         '())))
               ((= //s/t //t_/intersection)
                (@paste_over
                  (@mth_sequence
                    (let ((l /v) (reduce-result '()))
                      (cond ((null? l) '())
                            (#t
                             (set! reduce-result (car l))
                             (set! l (cdr l))
                             (let while-loop ()
                               (cond ((not (null? l))
                                      (set! reduce-result
                                        (@set_intersect reduce-result (car l)))
                                      (set! l (cdr l))
                                      (while-loop))
                                     (#t #t)))
                             reduce-result))))))
               ((= //s/t //t_/union)
                (@paste_over
                  (@mth_sequence
                    (let ((l /v) (reduce-result '()))
                      (cond ((null? l) '())
                            (#t
                             (set! reduce-result (car l))
                             (set! l (cdr l))
                             (let while-loop ()
                               (cond ((not (null? l))
                                      (set! reduce-result
                                        (@set_union reduce-result (car l)))
                                      (set! l (cdr l))
                                      (while-loop))
                                     (#t #t)))
                             reduce-result))))))
               ((= //s/t //t_/negate)
                (@paste_over
                  (@make //t_/number (- 0 (car /v)) '())))
               ((= //s/t //t_/invert))
               ((= //s/t //t_/div)
                (cond ((not (= (let ((name /v))
                                 (if (vector? name)
                                   (vector-ref name (- 2 1))
                                   (list-ref name (- 2 1))))
                               0))
                       (@paste_over
                         (@make //t_/number
                                (quotient
                                  (let ((name /v))
                                    (if (vector? name)
                                      (vector-ref name (- 1 1))
                                      (list-ref name (- 1 1))))
                                  (let ((name /v))
                                    (if (vector? name)
                                      (vector-ref name (- 2 1))
                                      (list-ref name (- 2 1)))))
                                '())))))
               ((= //s/t //t_/mod)
                (cond ((not (= (let ((name /v))
                                 (if (vector? name)
                                   (vector-ref name (- 2 1))
                                   (list-ref name (- 2 1))))
                               0))
                       (@paste_over
                         (@make //t_/number
                                (modulo
                                  (let ((name /v))
                                    (if (vector? name)
                                      (vector-ref name (- 1 1))
                                      (list-ref name (- 1 1))))
                                  (let ((name /v))
                                    (if (vector? name)
                                      (vector-ref name (- 2 1))
                                      (list-ref name (- 2 1)))))
                                '())))))
               ((= //s/t //t_/abs)
                (@paste_over
                  (@make //t_/number (abs (car /v)) '())))
               ((= //s/t //t_/sgn)
                (@paste_over
                  (@make //t_/number (sgn (car /v)) '())))
               ((= //s/t //t_/int)
                (@paste_over
                  (@make //t_/number (int (car /v)) '())))
               ((= //s/t //t_/frac)
                (@paste_over
                  (@make //t_/number (frac (car /v)) '())))
               ((= //s/t //t_/length)
                (@paste_over
                  (@make //t_/number
                         (if (vector? (car /v))
                           (vector-length (car /v))
                           (length (car /v)))
                         '())))
               ((= //s/t //t_/slength)
                (@paste_over
                  (@make //t_/number (string-length (car /v)) '())))
               ((= //s/t //t_/reverse)
                (@paste_over (@mth_sequence (reverse (car /v)))))
               ((= //s/t //t_/set_/diff)
                (@paste_over
                  (@mth_sequence
                    (@set_difference
                      (let ((name /v))
                        (if (vector? name)
                          (vector-ref name (- 1 1))
                          (list-ref name (- 1 1))))
                      (let ((name /v))
                        (if (vector? name)
                          (vector-ref name (- 2 1))
                          (list-ref name (- 2 1))))))))
               ((= //s/t //t_/concat)
                (@paste_over
                  (@mth_sequence
                    (let ((l /v) (reduce-result '()))
                      (cond ((null? l) '())
                            (#t
                             (set! reduce-result (car l))
                             (set! l (cdr l))
                             (let while-loop ()
                               (cond ((not (null? l))
                                      (set! reduce-result
                                        (concat reduce-result (car l)))
                                      (set! l (cdr l))
                                      (while-loop))
                                     (#t #t)))
                             reduce-result))))))
               ((= //s/t //t_/minus)
                (@paste_over
                  (@make //t_/number
                         (let ((l /v) (reduce-result '()))
                           (cond ((null? l) '())
                                 (#t
                                  (set! reduce-result (car l))
                                  (set! l (cdr l))
                                  (let while-loop ()
                                    (cond ((not (null? l))
                                           (set! reduce-result
                                             (- reduce-result (car l)))
                                           (set! l (cdr l))
                                           (while-loop))
                                          (#t #t)))
                                  reduce-result)))
                         '())))
               ((= //s/t //t_/divide)
                (let while-loop ()
                  (cond ((and (> (if (vector? /v)
                                   (vector-length /v)
                                   (length /v))
                                 1)
                              (not (= (let ((name /v))
                                        (if (vector? name)
                                          (vector-ref name (- 2 1))
                                          (list-ref name (- 2 1))))
                                      0))
                              (= (modulo
                                   (let ((name /v))
                                     (if (vector? name)
                                       (vector-ref name (- 1 1))
                                       (list-ref name (- 1 1))))
                                   (let ((name /v))
                                     (if (vector? name)
                                       (vector-ref name (- 2 1))
                                       (list-ref name (- 2 1)))))
                                 0))
                         (set! /v
                           (cons (/ (let ((name /v))
                                      (if (vector? name)
                                        (vector-ref name (- 1 1))
                                        (list-ref name (- 1 1))))
                                    (let ((name /v))
                                      (if (vector? name)
                                        (vector-ref name (- 2 1))
                                        (list-ref name (- 2 1)))))
                                 (@final_seg /v 3)))
                         (while-loop))
                        (#t #t)))
                (cond ((= (if (vector? /v) (vector-length /v) (length /v))
                          1)
                       (@paste_over
                         (@make //t_/number
                                (let ((name /v))
                                  (if (vector? name)
                                    (vector-ref name (- 1 1))
                                    (list-ref name (- 1 1))))
                                '())))))
               ((= //s/t //t_/if)
                (cond ((= (@st (list-ref (@i) (+ 1 1))) //t_/true)
                       (@paste_over (list-ref (@i) (+ 1 2))))
                      (#t (@paste_over (list-ref (@i) (+ 1 3))))))
               ((= //s/t //t_/index)
                (cond ((= (@size (list-ref (@i) (+ 1 1))) 2)
                       (@paste_over
                         (@make //t_/number
                                (let ((index-result
                                        (substring?
                                          (@v (list-ref
                                                (list-ref (@i) (+ 1 1))
                                                (+ 1 1)))
                                          (@v (list-ref
                                                (list-ref (@i) (+ 1 1))
                                                (+ 1 2))))))
                                  (if index-result index-result -1))
                                '())))
                      (#t
                       (@paste_over
                         (@make //t_/number
                                (let* ((s (@v (list-ref
                                                (list-ref (@i) (+ 1 1))
                                                (+ 1 2))))
                                       (start (@v (list-ref
                                                    (list-ref (@i) (+ 1 1))
                                                    (+ 1 3))))
                                       (index-result
                                         (substring?
                                           (@v (list-ref
                                                 (list-ref (@i) (+ 1 1))
                                                 (+ 1 1)))
                                           (substring
                                             s
                                             start
                                             (string-length s)))))
                                  (if index-result (+ start index-result) -1))
                                '())))))
               ((= //s/t //t_/substr)
                (cond ((>= (@v (list-ref (list-ref (@i) (+ 1 1)) (+ 1 2)))
                           (string-length
                             (@v (list-ref (list-ref (@i) (+ 1 1)) (+ 1 1)))))
                       #t)
                      ((= (@size (list-ref (@i) (+ 1 1))) 2)
                       (@paste_over
                         (@make //t_/string
                                (let ((s (@v (list-ref
                                               (list-ref (@i) (+ 1 1))
                                               (+ 1 1)))))
                                  (substring
                                    s
                                    (@v (list-ref
                                          (list-ref (@i) (+ 1 1))
                                          (+ 1 2)))
                                    (string-length s)))
                                '())))
                      (#t
                       (@paste_over
                         (@make //t_/string
                                (let ((f (@v (list-ref
                                               (list-ref (@i) (+ 1 1))
                                               (+ 1 2)))))
                                  (substring
                                    (@v (list-ref
                                          (list-ref (@i) (+ 1 1))
                                          (+ 1 1)))
                                    f
                                    (+ f
                                       (@v (list-ref
                                             (list-ref (@i) (+ 1 1))
                                             (+ 1 3))))))
                                '())))))
               ((or (= //s/t //t_/tail) (= //s/t //t_/head)) #t)
               (#t
                (begin
                  (display
                    "ERROR!!! Unknown type in @Mth_Evaluate: ")
                  (begin
                    (display (@type_name //s/t))
                    (begin
                      (display "(")
                      (begin
                        (display //s/t)
                        (begin (display ")") (newline) (force-output)))))))))))

(define (/foreach-maths-4 //depth //a/s_/type)
  (cond ((and (@cs? (@i))
              (> (vector-ref //eval_/op (- (@st (@i)) 1)) 0)
              (@mth_constants?
                (@cs (@i))
                (vector-ref //eval_/op (- (@st (@i)) 1))))
         (set! //s/t (@st (@i)))
         (set! /v (@mth_values (@cs (@i))))
         (let ((/vv '()))
           (let ((var-save /n) (seq-save /v))
             (if (vector? seq-save)
               (set! seq-save (vector-elts seq-save)))
             (let for-in-loop ((for-tmp seq-save))
               (cond ((not (null? for-tmp))
                      (set! /n (car for-tmp))
                      (cond ((and (string? /n)
                                  (@starts_with? /n "hex 0x")
                                  (< (string-length /n) 14))
                             (set! /vv
                               (cons (@hex_to_num
                                       (let ((s /n))
                                         (substring s 6 (string-length s))))
                                     /vv)))
                            (#t (set! /vv (cons /n /vv))))
                      (for-in-loop (cdr for-tmp)))
                     (#t #t)))
             (set! /n var-save))
           (set! /v (reverse /vv)))
         (cond ((= //s/t //t_/and)
                (cond ((not (member //t_/false (@mth_types (@cs (@i)))))
                       (@paste_over //mth_/true))
                      (#t (@paste_over //mth_/false))))
               ((= //s/t //t_/or)
                (cond ((member //t_/true (@mth_types (@cs (@i))))
                       (@paste_over //mth_/true))
                      (#t (@paste_over //mth_/false))))
               ((= //s/t //t_/not)
                (cond ((= (@st (list-ref (@i) (+ 1 1))) //t_/false)
                       (@paste_over //mth_/true))
                      (#t (@paste_over //mth_/false))))
               ((= //s/t //t_/even)
                (cond ((even? (car /v)) (@paste_over //mth_/true))
                      (#t (@paste_over //mth_/false))))
               ((= //s/t //t_/odd)
                (cond ((odd? (car /v)) (@paste_over //mth_/true))
                      (#t (@paste_over //mth_/false))))
               ((= //s/t //t_/subset)
                (cond ((@set_subset?
                         (let ((name /v))
                           (if (vector? name)
                             (vector-ref name (- 1 1))
                             (list-ref name (- 1 1))))
                         (let ((name /v))
                           (if (vector? name)
                             (vector-ref name (- 2 1))
                             (list-ref name (- 2 1)))))
                       (@paste_over //mth_/true))
                      (#t (@paste_over //mth_/false))))
               ((= //s/t //t_/member)
                (cond ((member
                         (let ((name /v))
                           (if (vector? name)
                             (vector-ref name (- 1 1))
                             (list-ref name (- 1 1))))
                         (let ((name /v))
                           (if (vector? name)
                             (vector-ref name (- 2 1))
                             (list-ref name (- 2 1)))))
                       (@paste_over //mth_/true))
                      (#t (@paste_over //mth_/false))))
               ((= //s/t //t_/in)
                (cond ((member
                         (let ((name /v))
                           (if (vector? name)
                             (vector-ref name (- 1 1))
                             (list-ref name (- 1 1))))
                         (let ((name /v))
                           (if (vector? name)
                             (vector-ref name (- 2 1))
                             (list-ref name (- 2 1)))))
                       (@paste_over //mth_/true))
                      (#t (@paste_over //mth_/false))))
               ((= //s/t //t_/not_/in)
                (cond ((not (member
                              (let ((name /v))
                                (if (vector? name)
                                  (vector-ref name (- 1 1))
                                  (list-ref name (- 1 1))))
                              (let ((name /v))
                                (if (vector? name)
                                  (vector-ref name (- 2 1))
                                  (list-ref name (- 2 1))))))
                       (@paste_over //mth_/true))
                      (#t (@paste_over //mth_/false))))
               ((= //s/t //t_/equal)
                (cond ((equal?
                         (let ((name /v))
                           (if (vector? name)
                             (vector-ref name (- 1 1))
                             (list-ref name (- 1 1))))
                         (let ((name /v))
                           (if (vector? name)
                             (vector-ref name (- 2 1))
                             (list-ref name (- 2 1)))))
                       (@paste_over //mth_/true))
                      (#t (@paste_over //mth_/false))))
               ((= //s/t //t_/not_/equal)
                (cond ((not (equal?
                              (let ((name /v))
                                (if (vector? name)
                                  (vector-ref name (- 1 1))
                                  (list-ref name (- 1 1))))
                              (let ((name /v))
                                (if (vector? name)
                                  (vector-ref name (- 2 1))
                                  (list-ref name (- 2 1))))))
                       (@paste_over //mth_/true))
                      (#t (@paste_over //mth_/false))))
               ((= //s/t //t_/less)
                (cond ((and #f
                            (string?
                              (let ((name /v))
                                (if (vector? name)
                                  (vector-ref name (- 1 1))
                                  (list-ref name (- 1 1)))))
                            (string?
                              (let ((name /v))
                                (if (vector? name)
                                  (vector-ref name (- 2 1))
                                  (list-ref name (- 2 1))))))
                       (cond ((string<?
                                (let ((name /v))
                                  (if (vector? name)
                                    (vector-ref name (- 1 1))
                                    (list-ref name (- 1 1))))
                                (let ((name /v))
                                  (if (vector? name)
                                    (vector-ref name (- 2 1))
                                    (list-ref name (- 2 1)))))
                              (@paste_over //mth_/true))
                             (#t (@paste_over //mth_/false))))
                      ((or (string?
                             (let ((name /v))
                               (if (vector? name)
                                 (vector-ref name (- 1 1))
                                 (list-ref name (- 1 1)))))
                           (string?
                             (let ((name /v))
                               (if (vector? name)
                                 (vector-ref name (- 2 1))
                                 (list-ref name (- 2 1))))))
                       #t)
                      (#t
                       (cond ((< (let ((name /v))
                                   (if (vector? name)
                                     (vector-ref name (- 1 1))
                                     (list-ref name (- 1 1))))
                                 (let ((name /v))
                                   (if (vector? name)
                                     (vector-ref name (- 2 1))
                                     (list-ref name (- 2 1)))))
                              (@paste_over //mth_/true))
                             (#t (@paste_over //mth_/false))))))
               ((= //s/t //t_/less_/eq)
                (cond ((and #f
                            (string?
                              (let ((name /v))
                                (if (vector? name)
                                  (vector-ref name (- 1 1))
                                  (list-ref name (- 1 1)))))
                            (string?
                              (let ((name /v))
                                (if (vector? name)
                                  (vector-ref name (- 2 1))
                                  (list-ref name (- 2 1))))))
                       (cond ((string<=?
                                (let ((name /v))
                                  (if (vector? name)
                                    (vector-ref name (- 1 1))
                                    (list-ref name (- 1 1))))
                                (let ((name /v))
                                  (if (vector? name)
                                    (vector-ref name (- 2 1))
                                    (list-ref name (- 2 1)))))
                              (@paste_over //mth_/true))
                             (#t (@paste_over //mth_/false))))
                      ((or (string?
                             (let ((name /v))
                               (if (vector? name)
                                 (vector-ref name (- 1 1))
                                 (list-ref name (- 1 1)))))
                           (string?
                             (let ((name /v))
                               (if (vector? name)
                                 (vector-ref name (- 2 1))
                                 (list-ref name (- 2 1))))))
                       #t)
                      (#t
                       (cond ((<= (let ((name /v))
                                    (if (vector? name)
                                      (vector-ref name (- 1 1))
                                      (list-ref name (- 1 1))))
                                  (let ((name /v))
                                    (if (vector? name)
                                      (vector-ref name (- 2 1))
                                      (list-ref name (- 2 1)))))
                              (@paste_over //mth_/true))
                             (#t (@paste_over //mth_/false))))))
               ((= //s/t //t_/greater)
                (cond ((and #f
                            (string?
                              (let ((name /v))
                                (if (vector? name)
                                  (vector-ref name (- 1 1))
                                  (list-ref name (- 1 1)))))
                            (string?
                              (let ((name /v))
                                (if (vector? name)
                                  (vector-ref name (- 2 1))
                                  (list-ref name (- 2 1))))))
                       (cond ((string<?
                                (let ((name /v))
                                  (if (vector? name)
                                    (vector-ref name (- 2 1))
                                    (list-ref name (- 2 1))))
                                (let ((name /v))
                                  (if (vector? name)
                                    (vector-ref name (- 1 1))
                                    (list-ref name (- 1 1)))))
                              (@paste_over //mth_/true))
                             (#t (@paste_over //mth_/false))))
                      ((or (string?
                             (let ((name /v))
                               (if (vector? name)
                                 (vector-ref name (- 1 1))
                                 (list-ref name (- 1 1)))))
                           (string?
                             (let ((name /v))
                               (if (vector? name)
                                 (vector-ref name (- 2 1))
                                 (list-ref name (- 2 1))))))
                       #t)
                      (#t
                       (cond ((> (let ((name /v))
                                   (if (vector? name)
                                     (vector-ref name (- 1 1))
                                     (list-ref name (- 1 1))))
                                 (let ((name /v))
                                   (if (vector? name)
                                     (vector-ref name (- 2 1))
                                     (list-ref name (- 2 1)))))
                              (@paste_over //mth_/true))
                             (#t (@paste_over //mth_/false))))))
               ((= //s/t //t_/greater_/eq)
                (cond ((and #f
                            (string?
                              (let ((name /v))
                                (if (vector? name)
                                  (vector-ref name (- 1 1))
                                  (list-ref name (- 1 1)))))
                            (string?
                              (let ((name /v))
                                (if (vector? name)
                                  (vector-ref name (- 2 1))
                                  (list-ref name (- 2 1))))))
                       (cond ((string<=?
                                (let ((name /v))
                                  (if (vector? name)
                                    (vector-ref name (- 2 1))
                                    (list-ref name (- 2 1))))
                                (let ((name /v))
                                  (if (vector? name)
                                    (vector-ref name (- 1 1))
                                    (list-ref name (- 1 1)))))
                              (@paste_over //mth_/true))
                             (#t (@paste_over //mth_/false))))
                      ((or (string?
                             (let ((name /v))
                               (if (vector? name)
                                 (vector-ref name (- 1 1))
                                 (list-ref name (- 1 1)))))
                           (string?
                             (let ((name /v))
                               (if (vector? name)
                                 (vector-ref name (- 2 1))
                                 (list-ref name (- 2 1))))))
                       #t)
                      (#t
                       (cond ((>= (let ((name /v))
                                    (if (vector? name)
                                      (vector-ref name (- 1 1))
                                      (list-ref name (- 1 1))))
                                  (let ((name /v))
                                    (if (vector? name)
                                      (vector-ref name (- 2 1))
                                      (list-ref name (- 2 1)))))
                              (@paste_over //mth_/true))
                             (#t (@paste_over //mth_/false))))))
               ((= //s/t //t_/sequenceq)
                (cond ((= (@st (list-ref (@i) (+ 1 1))) //t_/sequence)
                       (@paste_over //mth_/true))
                      (#t (@paste_over //mth_/false))))
               ((= //s/t //t_/numberq)
                (cond ((= (@st (list-ref (@i) (+ 1 1))) //t_/number)
                       (@paste_over //mth_/true))
                      (#t (@paste_over //mth_/false))))
               ((= //s/t //t_/stringq)
                (cond ((= (@st (list-ref (@i) (+ 1 1))) //t_/string)
                       (@paste_over //mth_/true))
                      (#t (@paste_over //mth_/false))))
               ((= //s/t //t_/implies)
                (cond ((or (= (@st (list-ref (@i) (+ 1 1))) //t_/false)
                           (= (@st (list-ref (@i) (+ 1 2))) //t_/true))
                       (@paste_over //mth_/true))
                      (#t (@paste_over //mth_/false))))
               (#t
                (begin
                  (display
                    "ERROR!!! Unknown type in @Mth_Evaluate: ")
                  (begin
                    (display (@type_name //s/t))
                    (begin
                      (display "(")
                      (begin
                        (display //s/t)
                        (begin (display ")") (newline) (force-output)))))))))))

(define (/foreach-maths-5 //depth //a/s_/type)
  (cond ((@cs? (@i))
         (set! //s/t (@st (@i)))
         (cond ((= //s/t //t_/minus)
                (@paste_over
                  (@make //t_/plus
                         '()
                         (cons (list-ref (@i) (+ 1 1))
                               (let ((l (cdr (@cs (@i)))) (map-result '()))
                                 (let while-loop ()
                                   (cond ((not (null? l))
                                          (set! map-result
                                            (cons (@mth_negate (car l))
                                                  map-result))
                                          (set! l (cdr l))
                                          (while-loop))
                                         (#t #t)))
                                 (reverse map-result)))))
                (set! //s/t //t_/plus))
               ((= //s/t //t_/divide)
                (@paste_over
                  (@make //t_/times
                         '()
                         (cons (list-ref (@i) (+ 1 1))
                               (let ((l (cdr (@cs (@i)))) (map-result '()))
                                 (let while-loop ()
                                   (cond ((not (null? l))
                                          (set! map-result
                                            (cons (@mth_invert (car l))
                                                  map-result))
                                          (set! l (cdr l))
                                          (while-loop))
                                         (#t #t)))
                                 (reverse map-result)))))
                (set! //s/t //t_/times))
               ((and (= //s/t //t_/concat)
                     (= (@st (list-ref (@i) (+ 1 1))) //t_/concat))
                (@paste_over
                  (@make //t_/concat
                         '()
                         (concat
                           (@cs (list-ref (@i) (+ 1 1)))
                           (cdr (@cs (@i))))))))
         (cond ((= (vector-ref //reverse_/op (- //s/t 1)) //s/t)
                (set! /new '())
                (let ((var-save /x) (seq-save (@cs (@i))))
                  (if (vector? seq-save)
                    (set! seq-save (vector-elts seq-save)))
                  (let for-in-loop ((for-tmp seq-save))
                    (cond ((not (null? for-tmp))
                           (set! /x (car for-tmp))
                           (cond ((= (@st /x) //s/t)
                                  (set! /new (concat (reverse (@cs /x)) /new)))
                                 (#t (set! /new (cons /x /new))))
                           (for-in-loop (cdr for-tmp)))
                          (#t #t)))
                  (set! /x var-save))
                (@paste_over (@make //s/t '() (reverse /new))))))))

(define (/foreach-maths-6 //depth //a/s_/type)
  (set! //s/t (@st (@i)))
  (cond ((= (vector-ref //reverse_/op (- //s/t 1)) //s/t)
         (set! /new '())
         (let ((var-save /x) (seq-save (@cs (@i))))
           (if (vector? seq-save)
             (set! seq-save (vector-elts seq-save)))
           (let for-in-loop ((for-tmp seq-save))
             (cond ((not (null? for-tmp))
                    (set! /x (car for-tmp))
                    (cond ((= (@st /x) //s/t)
                           (set! /new (concat (reverse (@cs /x)) /new)))
                          (#t (set! /new (cons /x /new))))
                    (for-in-loop (cdr for-tmp)))
                   (#t #t)))
           (set! /x var-save))
         (@paste_over (@make //s/t '() (reverse /new))))))

(define (/foreach-maths-7 //depth //a/s_/type)
  (cond ((= (vector-ref //reverse_/op (- (@st (@i)) 1))
            (@st (@i)))
         (@paste_over
           (@mth_sort_merge_item (@i) (@st (@i)) 0)))
        ((and (= (@st (@i)) //t_/concat)
              (= (@size (@i)) 1))
         (@paste_over (list-ref (@i) (+ 1 1))))))

(define (/foreach-maths-8 //depth //a/s_/type)
  (set! /count 0)
  (cond ((or (= (@st (@i)) //t_/and)
             (= (@st (@i)) //t_/or))
         (let ((var-save /comp) (seq-save (@cs (@i))))
           (if (vector? seq-save)
             (set! seq-save (vector-elts seq-save)))
           (let for-in-loop ((for-tmp seq-save))
             (cond ((not (null? for-tmp))
                    (set! /comp (car for-tmp))
                    (cond ((@unsafe_test? /comp)
                           (set! /count (+ /count 1))))
                    (for-in-loop (cdr for-tmp)))
                   (#t #t)))
           (set! /comp var-save))))
  (cond ((= (vector-ref //reverse_/op (- (@st (@i)) 1))
            (@st (@i)))
         (@paste_over
           (@mth_sort_merge_item (@i) (@st (@i)) /count)))))

(define (/foreach-maths-9 //depth //a/s_/type)
  (cond ((@equal? (@i) /rel)
         (set! /change 1)
         (@paste_over /same))
        ((= (@st (@i))
            (vector-ref //reverse_/op (- (@st /rel) 1)))
         (cond ((and (@equal?
                       (list-ref (@i) (+ 1 2))
                       (list-ref /rel (+ 1 1)))
                     (@equal?
                       (list-ref (@i) (+ 1 1))
                       (list-ref /rel (+ 1 2))))
                (set! /change 1)
                (@paste_over /same))))
        ((= (@st (@i))
            (vector-ref //inverse_/op (- (@st /rel) 1)))
         (cond ((and (@equal?
                       (list-ref (@i) (+ 1 2))
                       (list-ref /rel (+ 1 2)))
                     (@equal?
                       (list-ref (@i) (+ 1 1))
                       (list-ref /rel (+ 1 1))))
                (set! /change 1)
                (@paste_over /diff))))
        ((= (@st (@i))
            (vector-ref
              //inverse_/op
              (- (vector-ref //reverse_/op (- (@st /rel) 1)) 1)))
         (cond ((and (@equal?
                       (list-ref (@i) (+ 1 2))
                       (list-ref /rel (+ 1 1)))
                     (@equal?
                       (list-ref (@i) (+ 1 1))
                       (list-ref /rel (+ 1 2))))
                (set! /change 1)
                (@paste_over /diff))))))

(define (/foreach-maths-10 //depth //a/s_/type)
  (cond ((@equal? (@i) (car /vars))
         (@paste_over (car /vals)))))

(define (/foreach-maths-11 //depth //a/s_/type)
  (cond ((@equal? (@i) (car /vars))
         (@paste_over (car /vals)))))

(define (/foreach-maths-12 //depth //a/s_/type)
  (cond ((@equal? (@i) /var) (@paste_over /val))))

(define (/foreach-maths-13 //depth //a/s_/type)
  (cond ((@equal? (@i) /var) (@paste_over /val))))

(define (/foreach-maths-14 //depth //a/s_/type)
  (cond ((@equal? //i (@i)) (set! //r (+ //r 1)))))

(define (/foreach-maths-15 //depth //a/s_/type)
  (cond ((= (@st (@i)) //t_/times)
         (@down)
         (let while-loop ()
           (cond ((and (@right?)
                       (< (vector-ref //mth_/ord (- (@st (@i)) 1))
                          (vector-ref //mth_/ord (- //t_/plus 1))))
                  (@right)
                  (while-loop))
                 (#t #t)))
         (cond ((and (= (@st (@i)) //t_/plus) (@right?))
                (let while-loop ()
                  (cond ((and (@right?)
                              (= (@st (list-ref
                                        (@parent)
                                        (+ 1 (+ (@posn_n) 1))))
                                 //t_/plus))
                         (begin
                           (@mth_multiply //t_/times //t_/plus //budget))
                         (while-loop))
                        (#t #t)))
                (@up)
                (cond ((= (@size (@i)) 1)
                       (@paste_over (list-ref (@i) (+ 1 1))))))))))

(define (/foreach-maths-16 //depth //a/s_/type)
  (cond ((= (@st (@i)) //t_/and)
         (@down)
         (let while-loop ()
           (cond ((and (@right?)
                       (< (vector-ref //mth_/ord (- (@st (@i)) 1))
                          (vector-ref //mth_/ord (- //t_/or 1))))
                  (@right)
                  (while-loop))
                 (#t #t)))
         (cond ((and (= (@st (@i)) //t_/or) (@right?))
                (let while-loop ()
                  (cond ((and (@right?)
                              (= (@st (list-ref
                                        (@parent)
                                        (+ 1 (+ (@posn_n) 1))))
                                 //t_/or))
                         (begin (@mth_multiply //t_/and //t_/or //budget))
                         (while-loop))
                        (#t #t)))
                (cond ((and (@right?)
                            (< (@size (@i)) (quotient //budget 2)))
                       (@right)
                       (@paste_over (@make //t_/or '() (list (@i))))
                       (@left)
                       (@mth_multiply //t_/and //t_/or //budget)))
                (@up)
                (cond ((= (@size (@i)) 1)
                       (@paste_over (list-ref (@i) (+ 1 1))))))))))

(define (/foreach-maths-17 //depth //a/s_/type)
  (cond ((and (= (@st (@i)) //t_/plus)
              (> (@mth_occs
                   //t_/times
                   (let ((l (@cs (@i))) (map-result '()))
                     (let while-loop ()
                       (cond ((not (null? l))
                              (set! map-result (cons (@st (car l)) map-result))
                              (set! l (cdr l))
                              (while-loop))
                             (#t #t)))
                     (reverse map-result)))
                 1))
         (@mth_factor //t_/plus //t_/times))))

(define (/foreach-maths-18 //depth //a/s_/type)
  (cond ((and (= (@st (@i)) //t_/or)
              (> (@mth_occs
                   //t_/and
                   (let ((l (@cs (@i))) (map-result '()))
                     (let while-loop ()
                       (cond ((not (null? l))
                              (set! map-result (cons (@st (car l)) map-result))
                              (set! l (cdr l))
                              (while-loop))
                             (#t #t)))
                     (reverse map-result)))
                 1))
         (@mth_factor //t_/or //t_/and))))

(define (/foreach-maths-19 //depth //a/s_/type)
  (cond ((and (= (@st (@i)) //t_/plus)
              (> (@mth_occs
                   //t_/times
                   (let ((l (@cs (@i))) (map-result '()))
                     (let while-loop ()
                       (cond ((not (null? l))
                              (set! map-result (cons (@st (car l)) map-result))
                              (set! l (cdr l))
                              (while-loop))
                             (#t #t)))
                     (reverse map-result)))
                 1))
         (@mth_factor //t_/plus //t_/times))))

(define (/foreach-maths-20 //depth //a/s_/type)
  (cond ((and (= (@st (@i)) //t_/or)
              (> (@mth_occs
                   //t_/and
                   (let ((l (@cs (@i))) (map-result '()))
                     (let while-loop ()
                       (cond ((not (null? l))
                              (set! map-result (cons (@st (car l)) map-result))
                              (set! l (cdr l))
                              (while-loop))
                             (#t #t)))
                     (reverse map-result)))
                 1))
         (@mth_factor //t_/or //t_/and))))

(define (/foreach-maths-21 //depth //a/s_/type)
  (cond ((and (= (@st (@i)) //t_/number) (< (@v (@i)) 0))
         (@paste_over
           (@make //t_/negate
                  '()
                  (list (@make //t_/number (- (@v (@i))) '())))))
        ((= (@st (@i)) //t_/times)
         (cond ((member
                  //t_/invert
                  (let ((l (@cs (@i))) (map-result '()))
                    (let while-loop ()
                      (cond ((not (null? l))
                             (set! map-result (cons (@st (car l)) map-result))
                             (set! l (cdr l))
                             (while-loop))
                            (#t #t)))
                    (reverse map-result)))
                (@mth_prettify_inverses
                  //t_/times
                  //t_/invert
                  //t_/divide))))
        ((= (@st (@i)) //t_/plus)
         (cond ((member
                  //t_/negate
                  (let ((l (@cs (@i))) (map-result '()))
                    (let while-loop ()
                      (cond ((not (null? l))
                             (set! map-result (cons (@st (car l)) map-result))
                             (set! l (cdr l))
                             (while-loop))
                            (#t #t)))
                    (reverse map-result)))
                (@mth_prettify_inverses
                  //t_/plus
                  //t_/negate
                  //t_/minus))))
        ((and (= (@st (@i)) //t_/concat)
              (> (@size (@i)) 2))
         (@paste_over (@mth_bug_fix_concat (@i))))))

(define (/foreach-maths-22 //depth //a/s_/type)
  (cond ((and (= (@size (@i)) 2)
              (> (vector-ref //reverse_/op (- (@st (@i)) 1)) 0))
         (cond ((and (= (@st (list-ref (@i) (+ 1 1)))
                        //t_/x_/funct_/call)
                     (equal?
                       (@v (list-ref (list-ref (@i) (+ 1 1)) (+ 1 1)))
                       (@make_name "string")))
                (@paste_over
                  (@make (vector-ref //reverse_/op (- (@st (@i)) 1))
                         '()
                         (list (list-ref (@i) (+ 1 2))
                               (list-ref (@i) (+ 1 1))))))
               ((and (= (@st (list-ref (@i) (+ 1 2))) //t_/negate)
                     (= (@st (list-ref (list-ref (@i) (+ 1 2)) (+ 1 1)))
                        //t_/number))
                #t)
               ((or (@mth_lt?
                      (list-ref (@i) (+ 1 2))
                      (list-ref (@i) (+ 1 1)))
                    (and (or (= (@st (list-ref (@i) (+ 1 2))) //t_/variable)
                             (= (@st (list-ref (@i) (+ 1 2)))
                                //t_/primed_/var))
                         (and (not (= (@st (list-ref (@i) (+ 1 1)))
                                      //t_/variable))
                              (not (= (@st (list-ref (@i) (+ 1 1)))
                                      //t_/primed_/var)))))
                (@paste_over
                  (@make (vector-ref //reverse_/op (- (@st (@i)) 1))
                         '()
                         (list (list-ref (@i) (+ 1 2))
                               (list-ref (@i) (+ 1 1))))))))))

(define (/foreach-maths-23 //depth //a/s_/type)
  (cond ((= (@st (@i)) //t_/times)
         (cond ((= (@st (list-ref (@i) (+ 1 (@size (@i)))))
                   //t_/number)
                (@paste_over
                  (@make //t_/times
                         '()
                         (cons (list-ref (@i) (+ 1 (@size (@i))))
                               (butlast-1 (@cs (@i)))))))))))

(define (/foreach-maths-24 //depth //a/s_/type)
  (cond ((= (@st (@i)) //t_/x_/funct_/call)
         (cond ((and (equal? (@v (list-ref (@i) (+ 1 1))) /bit_and)
                     (@mth_all_constants?
                       (@cs (list-ref (@i) (+ 1 2)))))
                (@simplify_bit /bit_and))
               ((and (equal? (@v (list-ref (@i) (+ 1 1))) /bit_or)
                     (@mth_all_constants?
                       (@cs (list-ref (@i) (+ 1 2)))))
                (@simplify_bit /bit_or))
               ((and (equal? (@v (list-ref (@i) (+ 1 1))) /bit_xor)
                     (@mth_all_constants?
                       (@cs (list-ref (@i) (+ 1 2)))))
                (@simplify_bit /bit_xor))
               ((and (equal? (@v (list-ref (@i) (+ 1 1))) /bit_or)
                     (= (@size (list-ref (@i) (+ 1 2))) 2)
                     (= (@st (list-ref (list-ref (@i) (+ 1 2)) (+ 1 1)))
                        //t_/number)
                     (= (@v (list-ref (list-ref (@i) (+ 1 2)) (+ 1 1)))
                        0))
                (@paste_over
                  (list-ref (list-ref (@i) (+ 1 2)) (+ 1 2))))
               ((and (equal? (@v (list-ref (@i) (+ 1 1))) /bit_or)
                     (= (@size (list-ref (@i) (+ 1 2))) 2)
                     (= (@st (list-ref (list-ref (@i) (+ 1 2)) (+ 1 2)))
                        //t_/number)
                     (= (@v (list-ref (list-ref (@i) (+ 1 2)) (+ 1 2)))
                        0))
                (@paste_over
                  (list-ref (list-ref (@i) (+ 1 2)) (+ 1 1))))))))

(define (/foreach-maths-25 //depth //a/s_/type)
  (cond ((= (@st (@or /not_/b (@i))) //t_/true)
         (@paste_over //mth_/true))
        ((= (@st (@and //b (@i))) //t_/false)
         (@paste_over //mth_/false))))

(define (/foreach-maths-26 //depth //a/s_/type)
  (cond ((not (null? (gethash /replace (@v (@i)))))
         (@paste_over (gethash /replace (@v (@i)))))))

(define (/foreach-maths-27 //depth //a/s_/type)
  (cond ((equal? (@v (@i)) /v)
         (set! /count (+ /count 1)))))

(define (/foreach-maths-28 //depth //a/s_/type)
  (let ((/__/o/k 1))
    (set! /__/o/k
      (@new_match /%const__maths__1 (@i) /__/o/k))
    (cond ((= /__/o/k 1)
           (let ((/__exp_save /exp) (/__var_save /var))
             (set! /exp (vector-ref /__/match_array 1))
             (set! /var (vector-ref /__/match_array 0))
             (@paste_over //mth_/true)
             (set! /exp /__exp_save)
             (set! /var /__var_save)))))
  (let ((/__/o/k 1))
    (set! /__/o/k
      (@new_match /%const__maths__1 (@i) /__/o/k))
    (cond ((= /__/o/k 1)
           (let ((/__var_save /var) (/__exp_save /exp))
             (set! /var (vector-ref /__/match_array 1))
             (set! /exp (vector-ref /__/match_array 0))
             (@paste_over //mth_/true)
             (set! /var /__var_save)
             (set! /exp /__exp_save))))))

(define (/foreach-maths-29 //depth //a/s_/type)
  (cond ((and (= (@st (@i)) //t_/not)
              (or (= (@st (list-ref (@i) (+ 1 1)))
                     //t_/b/funct_/call)
                  (= (@st (list-ref (@i) (+ 1 1)))
                     //t_/x_/b/funct_/call)))
         (set! /calls
           (cons (list-ref (@i) (+ 1 1)) /calls)))))

(define (/foreach-maths-30 //depth //a/s_/type)
  (cond ((@equal? (@i) /old) (@paste_over /new))))

(define /%const__maths__1
  (@make 313
         '()
         (list (@make 217 -1 '()) (@make 217 -2 '()))))

(set! //mth_/true (@make //t_/true '() '()))

(set! //mth_/false (@make //t_/false '() '()))

(set! //mth_0 (@make //t_/number 0 '()))

(set! //mth_1 (@make //t_/number 1 '()))

(set! //mth_m1 (@make //t_/number (- 1) '()))

(set! //mth_/empty (@make //t_/sequence '() '()))

(set! //qry_/simple (@make_name "Qry_Simple"))

(set! //mth_/rels
  (@make_set
    (list //t_/equal
          //t_/not_/equal
          //t_/less
          //t_/less_/eq
          //t_/greater
          //t_/greater_/eq)))

(define (@mth_init)
  (set! //comm_/ops
    (list //t_/plus
          //t_/times
          //t_/union
          //t_/intersection
          //t_/equal
          //t_/not_/equal
          //t_/and
          //t_/or
          //t_/max
          //t_/min))
  (set! //reverse_/op (make-vector 1999 0))
  (let ((var-save /op) (seq-save //comm_/ops))
    (if (vector? seq-save)
      (set! seq-save (vector-elts seq-save)))
    (let for-in-loop ((for-tmp seq-save))
      (cond ((not (null? for-tmp))
             (set! /op (car for-tmp))
             (vector-set! //reverse_/op (- /op 1) /op)
             (for-in-loop (cdr for-tmp)))
            (#t #t)))
    (set! /op var-save))
  (vector-set!
    //reverse_/op
    (- //t_/less 1)
    //t_/greater)
  (vector-set!
    //reverse_/op
    (- //t_/greater 1)
    //t_/less)
  (vector-set!
    //reverse_/op
    (- //t_/less_/eq 1)
    //t_/greater_/eq)
  (vector-set!
    //reverse_/op
    (- //t_/greater_/eq 1)
    //t_/less_/eq)
  (set! //inverse_/op (make-vector 1999 0))
  (vector-set!
    //inverse_/op
    (- //t_/less 1)
    //t_/greater_/eq)
  (vector-set!
    //inverse_/op
    (- //t_/greater 1)
    //t_/less_/eq)
  (vector-set!
    //inverse_/op
    (- //t_/less_/eq 1)
    //t_/greater)
  (vector-set!
    //inverse_/op
    (- //t_/greater_/eq 1)
    //t_/less)
  (vector-set!
    //inverse_/op
    (- //t_/equal 1)
    //t_/not_/equal)
  (vector-set!
    //inverse_/op
    (- //t_/not_/equal 1)
    //t_/equal)
  (vector-set!
    //inverse_/op
    (- //t_/and 1)
    //t_/or)
  (vector-set!
    //inverse_/op
    (- //t_/or 1)
    //t_/and)
  (vector-set!
    //inverse_/op
    (- //t_/odd 1)
    //t_/even)
  (vector-set!
    //inverse_/op
    (- //t_/even 1)
    //t_/odd)
  (vector-set!
    //inverse_/op
    (- //t_/in 1)
    //t_/not_/in)
  (vector-set!
    //inverse_/op
    (- //t_/not_/in 1)
    //t_/in)
  (set! //eval_/ops_/gen
    (list //t_/and
          //t_/or
          //t_/not
          //t_/subset
          //t_/member
          //t_/equal
          //t_/not_/equal
          //t_/if
          //t_/intersection
          //t_/union
          //t_/set_/diff
          //t_/length
          //t_/reverse
          //t_/concat
          //t_/sequenceq
          //t_/numberq
          //t_/stringq
          //t_/implies
          //t_/in
          //t_/not_/in
          //t_/x_/funct_/call
          //t_/slength
          //t_/length
          //t_/forall
          //t_/exists
          //t_/less
          //t_/less_/eq
          //t_/greater
          //t_/greater_/eq
          //t_/index
          //t_/substr
          //t_/head
          //t_/tail
          //t_/m/w_/funct_/call))
  (set! //eval_/ops_/num
    (list //t_/even
          //t_/odd
          //t_/abs
          //t_/sgn
          //t_/int
          //t_/frac
          //t_/max
          //t_/min
          //t_/exponent
          //t_/times
          //t_/divide
          //t_/plus
          //t_/div
          //t_/mod
          //t_/negate
          //t_/invert
          //t_/minus))
  (set! //eval_/op (make-vector 1999 0))
  (let ((var-save /op) (seq-save //eval_/ops_/gen))
    (if (vector? seq-save)
      (set! seq-save (vector-elts seq-save)))
    (let for-in-loop ((for-tmp seq-save))
      (cond ((not (null? for-tmp))
             (set! /op (car for-tmp))
             (vector-set! //eval_/op (- /op 1) 1)
             (for-in-loop (cdr for-tmp)))
            (#t #t)))
    (set! /op var-save))
  (let ((var-save /op) (seq-save //eval_/ops_/num))
    (if (vector? seq-save)
      (set! seq-save (vector-elts seq-save)))
    (let for-in-loop ((for-tmp seq-save))
      (cond ((not (null? for-tmp))
             (set! /op (car for-tmp))
             (vector-set! //eval_/op (- /op 1) 2)
             (for-in-loop (cdr for-tmp)))
            (#t #t)))
    (set! /op var-save))
  (set! //idempotent_/ops
    (list //t_/union
          //t_/intersection
          //t_/and
          //t_/or
          //t_/max
          //t_/min))
  (set! //power_/op (make-vector 1999 0))
  (let ((var-save /op) (seq-save //idempotent_/ops))
    (if (vector? seq-save)
      (set! seq-save (vector-elts seq-save)))
    (let for-in-loop ((for-tmp seq-save))
      (cond ((not (null? for-tmp))
             (set! /op (car for-tmp))
             (vector-set! //power_/op (- /op 1) /op)
             (for-in-loop (cdr for-tmp)))
            (#t #t)))
    (set! /op var-save))
  (vector-set!
    //power_/op
    (- //t_/plus 1)
    //t_/times)
  (vector-set!
    //power_/op
    (- //t_/times 1)
    //t_/exponent)
  (set! //identity_/value (make-vector 1999 '()))
  (vector-set!
    //identity_/value
    (- //t_/plus 1)
    //mth_0)
  (vector-set!
    //identity_/value
    (- //t_/times 1)
    //mth_1)
  (vector-set!
    //identity_/value
    (- //t_/union 1)
    //mth_/empty)
  (vector-set!
    //identity_/value
    (- //t_/and 1)
    //mth_/true)
  (vector-set!
    //identity_/value
    (- //t_/or 1)
    //mth_/false)
  (set! //zero_/value (make-vector 1999 '()))
  (vector-set!
    //zero_/value
    (- //t_/times 1)
    //mth_0)
  (vector-set!
    //zero_/value
    (- //t_/intersection 1)
    //mth_/empty)
  (vector-set!
    //zero_/value
    (- //t_/and 1)
    //mth_/false)
  (vector-set!
    //zero_/value
    (- //t_/or 1)
    //mth_/true)
  (set! //mth_/ord (make-vector 1999 1999))
  (vector-set! //mth_/ord (- //t_/and 1) 1)
  (vector-set! //mth_/ord (- //t_/or 1) 2)
  (vector-set! //mth_/ord (- //t_/forall 1) 4)
  (vector-set! //mth_/ord (- //t_/exists 1) 5)
  (vector-set! //mth_/ord (- //t_/even 1) 6)
  (vector-set! //mth_/ord (- //t_/odd 1) 7)
  (vector-set! //mth_/ord (- //t_/empty 1) 8)
  (vector-set! //mth_/ord (- //t_/subset 1) 9)
  (vector-set! //mth_/ord (- //t_/member 1) 10)
  (vector-set! //mth_/ord (- //t_/equal 1) 11)
  (vector-set! //mth_/ord (- //t_/not_/equal 1) 11)
  (vector-set! //mth_/ord (- //t_/less 1) 13)
  (vector-set! //mth_/ord (- //t_/greater 1) 14)
  (vector-set! //mth_/ord (- //t_/less_/eq 1) 15)
  (vector-set!
    //mth_/ord
    (- //t_/greater_/eq 1)
    16)
  (vector-set! //mth_/ord (- //t_/if 1) 19)
  (vector-set! //mth_/ord (- //t_/abs 1) 20)
  (vector-set! //mth_/ord (- //t_/sgn 1) 21)
  (vector-set! //mth_/ord (- //t_/int 1) 22)
  (vector-set! //mth_/ord (- //t_/frac 1) 23)
  (vector-set! //mth_/ord (- //t_/max 1) 24)
  (vector-set! //mth_/ord (- //t_/min 1) 25)
  (vector-set!
    //mth_/ord
    (- //t_/intersection 1)
    26)
  (vector-set! //mth_/ord (- //t_/union 1) 27)
  (vector-set! //mth_/ord (- //t_/set_/diff 1) 28)
  (vector-set! //mth_/ord (- //t_/powerset 1) 29)
  (vector-set! //mth_/ord (- //t_/set 1) 30)
  (vector-set! //mth_/ord (- //t_/array 1) 31)
  (vector-set! //mth_/ord (- //t_/head 1) 32)
  (vector-set! //mth_/ord (- //t_/tail 1) 33)
  (vector-set! //mth_/ord (- //t_/butlast 1) 34)
  (vector-set! //mth_/ord (- //t_/last 1) 35)
  (vector-set! //mth_/ord (- //t_/length 1) 36)
  (vector-set! //mth_/ord (- //t_/reverse 1) 37)
  (vector-set! //mth_/ord (- //t_/exponent 1) 38)
  (vector-set! //mth_/ord (- //t_/times 1) 39)
  (vector-set! //mth_/ord (- //t_/plus 1) 40)
  (vector-set! //mth_/ord (- //t_/concat 1) 41)
  (vector-set! //mth_/ord (- //t_/div 1) 42)
  (vector-set! //mth_/ord (- //t_/mod 1) 43)
  (vector-set! //mth_/ord (- //t_/sequenceq 1) 44)
  (vector-set! //mth_/ord (- //t_/numberq 1) 45)
  (vector-set! //mth_/ord (- //t_/stringq 1) 46)
  (vector-set! //mth_/ord (- //t_/map 1) 47)
  (vector-set! //mth_/ord (- //t_/reduce 1) 48)
  (vector-set! //mth_/ord (- //t_/forall 1) 49)
  (vector-set! //mth_/ord (- //t_/exists 1) 50)
  (vector-set! //mth_/ord (- //t_/implies 1) 51)
  (vector-set! //mth_/ord (- //t_/in 1) 52)
  (vector-set! //mth_/ord (- //t_/not_/in 1) 53)
  (vector-set!
    //mth_/ord
    (- //t_/address_/of 1)
    70)
  (vector-set!
    //mth_/ord
    (- //t_/x_/funct_/call 1)
    71)
  (vector-set!
    //mth_/ord
    (- //t_/x_/b/funct_/call 1)
    72)
  (vector-set!
    //mth_/ord
    (- //t_/m/w_/funct_/call 1)
    73)
  (vector-set!
    //mth_/ord
    (- //t_/m/w_/b/funct_/call 1)
    74)
  (vector-set!
    //mth_/ord
    (- //t_/funct_/call 1)
    75)
  (vector-set!
    //mth_/ord
    (- //t_/b/funct_/call 1)
    76)
  (vector-set! //mth_/ord (- //t_/get_n 1) 77)
  (vector-set! //mth_/ord (- //t_/get 1) 78)
  (vector-set! //mth_/ord (- //t_/gethash 1) 79)
  (vector-set! //mth_/ord (- //t_/fill_/stat 1) 80)
  (vector-set! //mth_/ord (- //t_/fill_/expn 1) 81)
  (vector-set! //mth_/ord (- //t_/fill_/cond 1) 82)
  (vector-set! //mth_/ord (- //t_/fill_/defn 1) 83)
  (vector-set!
    //mth_/ord
    (- //t_/fill_/lvalue 1)
    84)
  (vector-set!
    //mth_/ord
    (- //t_/fill_/assign 1)
    85)
  (vector-set!
    //mth_/ord
    (- //t_/fill_/guarded 1)
    86)
  (vector-set!
    //mth_/ord
    (- //t_/fill_/action 1)
    87)
  (vector-set!
    //mth_/ord
    (- //t_/fill_/stats 1)
    88)
  (vector-set!
    //mth_/ord
    (- //t_/fill_/expns 1)
    89)
  (vector-set!
    //mth_/ord
    (- //t_/fill_/lvalues 1)
    91)
  (vector-set!
    //mth_/ord
    (- //t_/fill_/assigns 1)
    92)
  (vector-set!
    //mth_/ord
    (- //t_/fill_/defns 1)
    93)
  (vector-set! //mth_/ord (- //t_/negate 1) 100)
  (vector-set! //mth_/ord (- //t_/invert 1) 101)
  (vector-set!
    //mth_/ord
    (- //t_/primed_/var 1)
    200)
  (vector-set! //mth_/ord (- //t_/variable 1) 201)
  (vector-set! //mth_/ord (- //t_/struct 1) 202)
  (vector-set! //mth_/ord (- //t_/aref 1) 203)
  (vector-set! //mth_/ord (- //t_/sub_/seg 1) 204)
  (vector-set! //mth_/ord (- //t_/rel_/seg 1) 205)
  (vector-set!
    //mth_/ord
    (- //t_/final_/seg 1)
    206)
  (vector-set!
    //mth_/ord
    (- //t_/expn_/pat_/one 1)
    207)
  (vector-set!
    //mth_/ord
    (- //t_/expn_/pat_/many 1)
    208)
  (vector-set!
    //mth_/ord
    (- //t_/expn_/pat_/any 1)
    209)
  (vector-set! //mth_/ord (- //t_/mem 1) 210)
  (vector-set! //mth_/ord (- //t_/mem_/seg 1) 211)
  (vector-set! //mth_/ord (- //t_/mem_/rel 1) 212)
  (vector-set!
    //mth_/ord
    (- //t_/expn_/place 1)
    300)
  (vector-set!
    //mth_/ord
    (- //t_/var_/place 1)
    301)
  (vector-set!
    //mth_/ord
    (- //t_/cond_/place 1)
    302)
  (vector-set! //mth_/ord (- //t_/number 1) 303)
  (vector-set! //mth_/ord (- //t_/string 1) 304)
  (vector-set!
    //mth_/ord
    (- //t_/hash_/table 1)
    309)
  (vector-set! //mth_/ord (- //t_/true 1) 310)
  (vector-set! //mth_/ord (- //t_/false 1) 311)
  #t)

(@mth_init)

(set! //mth_/default_/budget 10)

(define (@set_budget /n)
  (set! //mth_/default_/budget /n))

(define (@budget) //mth_/default_/budget)

(define (@simplify_expn //expn)
  (@simplify //expn //mth_/default_/budget))

(define (@simplify_cond //c)
  (@simplify //c //mth_/default_/budget))

(define (@true? //c)
  (= (@st (@simplify //c //mth_/default_/budget))
     //t_/true))

(define (@false? //c)
  (= (@st (@simplify //c //mth_/default_/budget))
     //t_/false))

(define (@implies? //c1 //c2)
  (= (@st (@simplify
            (@make //t_/or
                   '()
                   (list (@make //t_/not '() (list //c1)) //c2))
            //mth_/default_/budget))
     //t_/true))

(define (@and //c1 //c2)
  (@simplify
    (@make //t_/and '() (list //c1 //c2))
    //mth_/default_/budget))

(define (@or //c1 //c2)
  (@simplify
    (@make //t_/or '() (list //c1 //c2))
    //mth_/default_/budget))

(define (@not //c)
  (@simplify
    (@make //t_/not '() (list //c))
    //mth_/default_/budget))

(define (@implies //c1 //c2)
  (@simplify
    (@make //t_/or
           '()
           (list (@make //t_/not '() (list //c1)) //c2))
    //mth_/default_/budget))

(define (@swap_expn /expn)
  (let ((/op-save /op)
        (/comps (@cs /expn))
        (funct-result '()))
    (set! /op
      (vector-ref //reverse_/op (- (@st /expn) 1)))
    (set! funct-result
      (if (= /op 0)
        /expn
        (@make /op
               '()
               (cons (let ((name /comps))
                       (if (vector? name)
                         (vector-ref name (- 2 1))
                         (list-ref name (- 2 1))))
                     (cons (let ((name /comps))
                             (if (vector? name)
                               (vector-ref name (- 1 1))
                               (list-ref name (- 1 1))))
                           (@final_seg /comps 3))))))
    (set! /op /op-save)
    funct-result))

(define (@mth_swappable? //x)
  (> (vector-ref //reverse_/op (- (@st //x) 1)) 0))

(define (@simplify //i-par //budget-par)
  (let ((//budget-save //budget)
        (//i-save //i)
        (/new-save /new)
        (/level (@dtable_get //i-par //qry_/simple))
        (funct-result '()))
    (set! //budget //budget-par)
    (set! //i //i-par)
    (set! /new //i-par)
    (cond ((and (not (null? /level))
                (>= (@dtable_value_part /level) //budget))
           #t)
          ((or (and (not (= (@gt //i) //t_/condition))
                    (not (= (@gt //i) //t_/expression)))
               (<= (vector-ref //eval_/op (- (@st //i) 1)) 0))
           (cond ((@cs? //i)
                  (let ((/comps '()))
                    (let ((var-save /comp) (seq-save (@cs //i)))
                      (if (vector? seq-save)
                        (set! seq-save (vector-elts seq-save)))
                      (let for-in-loop ((for-tmp seq-save))
                        (cond ((not (null? for-tmp))
                               (set! /comp (car for-tmp))
                               (set! /comps
                                 (cons (@simplify /comp //budget) /comps))
                               (for-in-loop (cdr for-tmp)))
                              (#t #t)))
                      (set! /comp var-save))
                    (set! /new
                      (@make (@st //i) '() (reverse /comps)))
                    (@dtable_put /new //qry_/simple //budget)))))
          (#t
           (cond ((= (@st //i) //t_/if)
                  (let ((/comps '()))
                    (let ((var-save /comp) (seq-save (@cs //i)))
                      (if (vector? seq-save)
                        (set! seq-save (vector-elts seq-save)))
                      (let for-in-loop ((for-tmp seq-save))
                        (cond ((not (null? for-tmp))
                               (set! /comp (car for-tmp))
                               (set! /comps
                                 (cons (@simplify /comp //budget) /comps))
                               (for-in-loop (cdr for-tmp)))
                              (#t #t)))
                      (set! /comp var-save))
                    (set! //i (@make (@st //i) '() (reverse /comps))))))
           (let ((/old-save /old)
                 (//orig_/budget //budget)
                 (//orig_/size (@total_size //i))
                 (//orig //i))
             (set! /old '())
             (@edit)
             (@new_program //i)
             (@simplify_bit_ops)
             (cond ((> //budget 5)
                    (@simplify_bfunct_calls //budget)))
             (set! /fl_flag2 0)
             (let while-loop ()
               (cond ((= /fl_flag2 0)
                      (cond ((= //budget 0) (set! /fl_flag2 1))
                            (#t
                             (cond ((and (= (@gt (@i)) //t_/condition)
                                         (@cs? (@i)))
                                    (@paste_over (@mth_de_morgan (@i)))))
                             (set! /fl_flag1 0)
                             (let while-loop ()
                               (cond ((= /fl_flag1 0)
                                      (begin
                                        (@mth_flatten)
                                        (@mth_evaluate)
                                        (@mth_sort_merge)
                                        (set! /old (@program))
                                        (@foreach_cond
                                          /foreach-maths-1
                                          0
                                          (@as_type)
                                          0)
                                        (cond ((null? (@program))
                                               (@new_program (@skips))))
                                        (cond ((< (@total_size (@i))
                                                  (* 2 //budget))
                                               (@mth_expand //budget)))
                                        (@foreach_cond
                                          /foreach-maths-2
                                          0
                                          (@as_type)
                                          0)
                                        (cond ((null? (@program))
                                               (@new_program (@skips))))
                                        (cond ((> (@total_size (@program))
                                                  (* //budget //orig_/size))
                                               (@paste_over //orig)
                                               (set! /fl_flag1 2))
                                              ((@equal? /old (@program))
                                               (set! /fl_flag1 1))
                                              (#t (set! /fl_flag1 0))))
                                      (while-loop))
                                     (#t #t)))
                             (cond ((= /fl_flag1 2) (set! /fl_flag2 1))
                                   (#t
                                    (set! /old (@program))
                                    (cond (#f
                                           (begin
                                             (display "Patterns 1: ")
                                             (begin
                                               (display //budget)
                                               (newline)
                                               (force-output)))
                                           (@pp_item (@i) 80 "")
                                           (begin
                                             (display "-----")
                                             (newline)
                                             (force-output))))
                                    (cond ((>= (@total_size (@i)) 3)
                                           (@mth_patterns //budget)))
                                    (cond (#f
                                           (begin
                                             (display "Patterns 2:")
                                             (newline)
                                             (force-output))
                                           (@pp_item (@i) 80 "")
                                           (begin
                                             (display "-----")
                                             (newline)
                                             (force-output))))
                                    (@mth_evaluate)
                                    (cond ((@equal? /old (@program))
                                           (set! /fl_flag2 1))
                                          (#t (set! /fl_flag2 0)))))))
                      (while-loop))
                     (#t #t)))
             (set! //budget //orig_/budget)
             (@mth_factorise //budget)
             (@mth_flatten)
             (@mth_prettify)
             (cond ((not (@equal? (@program) //orig))
                    (@mth_flatten)
                    (@mth_evaluate)
                    (@mth_sort_merge)
                    (@mth_factorise //budget)
                    (@mth_flatten)
                    (@mth_prettify)))
             (set! /new (@program))
             (cond ((> //budget 10)
                    (set! /new (@simplify /new (- //budget 10)))
                    (cond ((> (@total_size /new) (@total_size (@program)))
                           (set! /new (@program))))))
             (@undo_edit)
             (@dtable_put /new //qry_/simple //orig_/budget)
             (set! /old /old-save))))
    (set! funct-result /new)
    (set! //budget //budget-save)
    (set! //i //i-save)
    (set! /new /new-save)
    funct-result))

(define (@mth_evaluate)
  (let ((//s/t-save //s/t)
        (/v-save /v)
        (/new-save /new)
        (/badnum-save /badnum))
    (set! //s/t 0)
    (set! /v '())
    (set! /new '())
    (set! /badnum 0)
    (@foreach_expn /foreach-maths-3 0 (@as_type) 0)
    (cond ((null? (@program)) (@new_program (@skips))))
    (@foreach_cond /foreach-maths-4 0 (@as_type) 0)
    (cond ((null? (@program)) (@new_program (@skips))))
    (set! //s/t //s/t-save)
    (set! /v /v-save)
    (set! /new /new-save)
    (set! /badnum /badnum-save)))

(define (@mth_eval_exponent //x //y)
  (let ((//r-save //r) (funct-result '()))
    (set! //r '())
    (cond ((or (not (= (@st //x) //t_/number))
               (not (= (@st //y) //t_/number))
               (<= (@v //x) 0)
               (not (number? (@v //x)))
               (not (number? (@v //y)))
               (> (@v //y) 27))
           (set! //r
             (@make //t_/exponent '() (list //x //y))))
          (#t
           (set! //r
             (@make //t_/number
                    (integer-expt (@v //x) (@v //y))
                    '()))))
    (set! funct-result //r)
    (set! //r //r-save)
    funct-result))

(define (@mth_sequence //l)
  (let ((/comps '())
        (/val-save /val)
        (//r-save //r)
        (funct-result '()))
    (set! /val '())
    (set! //r '())
    (cond ((string? //l)
           (set! //r (@make //t_/string //l '())))
          (#t
           (let ((var-save /val) (seq-save //l))
             (if (vector? seq-save)
               (set! seq-save (vector-elts seq-save)))
             (let for-in-loop ((for-tmp seq-save))
               (cond ((not (null? for-tmp))
                      (set! /val (car for-tmp))
                      (cond ((number? /val)
                             (set! /comps
                               (cons (@make //t_/number /val '()) /comps)))
                            ((string? /val)
                             (set! /comps
                               (cons (@make //t_/string /val '()) /comps)))
                            ((sequence? /val)
                             (set! /comps (cons (@mth_sequence /val) /comps)))
                            (#t
                             (begin
                               (display
                                 "ERROR: Unknown value in Mth_Sequence: ")
                               (begin
                                 (display /val)
                                 (newline)
                                 (force-output)))))
                      (for-in-loop (cdr for-tmp)))
                     (#t #t)))
             (set! /val var-save))
           (set! //r
             (@make //t_/sequence
                    '()
                    (list (@make //t_/expressions '() (reverse /comps)))))))
    (set! funct-result //r)
    (set! /val /val-save)
    (set! //r //r-save)
    funct-result))

(define (@mth_constants? //l /type)
  (let ((//o/k 0))
    (cond ((and (= /type 1) (@mth_all_constants? //l))
           (set! //o/k 1))
          ((and (= /type 2) (@mth_all_numbers? //l))
           (set! //o/k 1)))
    (= //o/k 1)))

(define (@mth_all_constants? //l)
  (let ((//o/k 1))
    (let while-loop ()
      (cond ((and (= //o/k 1) (not (null? //l)))
             (cond ((not (@mth_constant? (car //l))) (set! //o/k 0))
                   (#t (set! //l (cdr //l))))
             (while-loop))
            (#t #t)))
    (= //o/k 1)))

(define (@mth_constant? //i)
  (or (= (@st //i) //t_/number)
      (= (@st //i) //t_/string)
      (= (@st //i) //t_/true)
      (= (@st //i) //t_/false)
      (and (= (@st //i) //t_/sequence)
           (@mth_all_constants?
             (@cs (list-ref //i (+ 1 1)))))
      (and (= (@st //i) //t_/expressions)
           (@mth_all_constants? (@cs //i)))))

(define (@mth_values //l)
  (let ((//r-save //r)
        (//i-save //i)
        (funct-result '()))
    (set! //r '())
    (set! //i '())
    (let ((var-save //i) (seq-save //l))
      (if (vector? seq-save)
        (set! seq-save (vector-elts seq-save)))
      (let for-in-loop ((for-tmp seq-save))
        (cond ((not (null? for-tmp))
               (set! //i (car for-tmp))
               (cond ((= (@st //i) //t_/sequence)
                      (set! //r
                        (cons (@mth_values (@cs (list-ref //i (+ 1 1))))
                              //r)))
                     (#t (set! //r (cons (@value //i) //r))))
               (for-in-loop (cdr for-tmp)))
              (#t #t)))
      (set! //i var-save))
    (set! funct-result (reverse //r))
    (set! //r //r-save)
    (set! //i //i-save)
    funct-result))

(define (@mth_types //l)
  (let ((//r-save //r) (funct-result '()))
    (set! //r '())
    (let while-loop ()
      (cond ((not (null? //l))
             (begin
               (set! //r (cons (@st (car //l)) //r))
               (set! //l (cdr //l)))
             (while-loop))
            (#t #t)))
    (set! funct-result (reverse //r))
    (set! //r //r-save)
    funct-result))

(define (@mth_all_numbers? //l)
  (let ((//o/k 1))
    (let while-loop ()
      (cond ((and (= //o/k 1) (not (null? //l)))
             (cond ((and (= (@st (car //l)) //t_/string)
                         (@starts_with? (@v (car //l)) "hex 0x")
                         (or (< (string-length (@v (car //l))) 14)
                             (@starts_with? (@v (car //l)) "hex 0x00")))
                    (set! //l (cdr //l)))
                   ((= (@st (car //l)) //t_/number)
                    (set! //l (cdr //l)))
                   (#t (set! //o/k 0)))
             (while-loop))
            (#t #t)))
    (= //o/k 1)))

(define (@mth_flatten)
  (let ((//s/t-save //s/t)
        (/new-save /new)
        (/x-save /x))
    (set! //s/t '())
    (set! /new '())
    (set! /x '())
    (@foreach_expn /foreach-maths-5 0 (@as_type) 0)
    (cond ((null? (@program)) (@new_program (@skips))))
    (cond ((= (@gt (@i)) //t_/condition)
           (@foreach_cond /foreach-maths-6 0 (@as_type) 0)
           (cond ((null? (@program)) (@new_program (@skips))))))
    (set! //s/t //s/t-save)
    (set! /new /new-save)
    (set! /x /x-save)))

(define (@mth_negate //i)
  (if (= (@st //i) //t_/plus)
    (@make //t_/plus
           '()
           (let ((l (@cs //i)) (map-result '()))
             (let while-loop ()
               (cond ((not (null? l))
                      (set! map-result
                        (cons (@mth_negate (car l)) map-result))
                      (set! l (cdr l))
                      (while-loop))
                     (#t #t)))
             (reverse map-result)))
    (if (or (= (@st //i) //t_/times)
            (= (@st //i) //t_/divide))
      (@make (@st //i)
             '()
             (cons (@mth_negate (list-ref //i (+ 1 1)))
                   (cdr (@cs //i))))
      (@make //t_/negate '() (list //i)))))

(define (@mth_invert //i)
  (if (= (@st //i) //t_/times)
    (@make //t_/times
           '()
           (let ((l (@cs //i)) (map-result '()))
             (let while-loop ()
               (cond ((not (null? l))
                      (set! map-result
                        (cons (@mth_invert (car l)) map-result))
                      (set! l (cdr l))
                      (while-loop))
                     (#t #t)))
             (reverse map-result)))
    (@make //t_/invert '() (list //i))))

(define (@mth_de_morgan //i-par)
  (let ((//i-save //i)
        (//r-save //r)
        (funct-result '()))
    (set! //i //i-par)
    (set! //r '())
    (cond ((= (@st //i) //t_/not)
           (cond ((or (= (@st (list-ref //i (+ 1 1))) //t_/and)
                      (= (@st (list-ref //i (+ 1 1))) //t_/or))
                  (set! //r
                    (@make (vector-ref
                             //inverse_/op
                             (- (@st (list-ref //i (+ 1 1))) 1))
                           '()
                           (let ((l (@cs (list-ref //i (+ 1 1))))
                                 (map-result '()))
                             (let while-loop ()
                               (cond ((not (null? l))
                                      (set! map-result
                                        (cons (@mth_de_morgan_not (car l))
                                              map-result))
                                      (set! l (cdr l))
                                      (while-loop))
                                     (#t #t)))
                             (reverse map-result)))))
                 ((> (vector-ref
                       //inverse_/op
                       (- (@st (list-ref //i (+ 1 1))) 1))
                     0)
                  (cond ((or (= (vector-ref
                                  //inverse_/op
                                  (- (@st (list-ref //i (+ 1 1))) 1))
                                //t_/greater)
                             (= (vector-ref
                                  //inverse_/op
                                  (- (@st (list-ref //i (+ 1 1))) 1))
                                //t_/greater_/eq))
                         (set! //r
                           (@make (vector-ref
                                    //reverse_/op
                                    (- (vector-ref
                                         //inverse_/op
                                         (- (@st (list-ref //i (+ 1 1))) 1))
                                       1))
                                  '()
                                  (list (@get //i (list 1 2))
                                        (@get //i (list 1 1))))))
                        (#t
                         (set! //r
                           (@make (vector-ref
                                    //inverse_/op
                                    (- (@st (list-ref //i (+ 1 1))) 1))
                                  '()
                                  (@cs (list-ref //i (+ 1 1))))))))
                 ((= (@st (list-ref //i (+ 1 1))) //t_/implies)
                  (set! //r
                    (@make //t_/and
                           '()
                           (list (@mth_de_morgan (@get //i (list 1 1)))
                                 (@mth_de_morgan_not (@get //i (list 1 2)))))))
                 ((= (@st (list-ref //i (+ 1 1))) //t_/not)
                  (set! //r (@mth_de_morgan (@get //i (list 1 1)))))
                 (#t (set! //r //i))))
          ((or (= (@st //i) //t_/greater)
               (= (@st //i) //t_/greater_/eq))
           (set! //r
             (@make (vector-ref //reverse_/op (- (@st //i) 1))
                    '()
                    (list (list-ref //i (+ 1 2))
                          (list-ref //i (+ 1 1))))))
          ((= (@st //i) //t_/implies)
           (set! //r
             (@make //t_/or
                    '()
                    (list (@mth_de_morgan_not (list-ref //i (+ 1 1)))
                          (@mth_de_morgan (list-ref //i (+ 1 2)))))))
          ((or (= (@st //i) //t_/and) (= (@st //i) //t_/or))
           (set! //r
             (@make (@st //i)
                    '()
                    (let ((l (@cs //i)) (map-result '()))
                      (let while-loop ()
                        (cond ((not (null? l))
                               (set! map-result
                                 (cons (@mth_de_morgan (car l)) map-result))
                               (set! l (cdr l))
                               (while-loop))
                              (#t #t)))
                      (reverse map-result)))))
          (#t (set! //r //i)))
    (set! funct-result //r)
    (set! //i //i-save)
    (set! //r //r-save)
    funct-result))

(define (@mth_de_morgan_not //i-par)
  (let ((//i-save //i)
        (//r-save //r)
        (funct-result '()))
    (set! //i //i-par)
    (set! //r '())
    (cond ((= (@st //i) //t_/not)
           (set! //r
             (@mth_de_morgan (list-ref //i (+ 1 1)))))
          ((or (= (@st //i) //t_/and) (= (@st //i) //t_/or))
           (set! //r
             (@make (vector-ref //inverse_/op (- (@st //i) 1))
                    '()
                    (let ((l (@cs //i)) (map-result '()))
                      (let while-loop ()
                        (cond ((not (null? l))
                               (set! map-result
                                 (cons (@mth_de_morgan_not (car l)) map-result))
                               (set! l (cdr l))
                               (while-loop))
                              (#t #t)))
                      (reverse map-result)))))
          ((> (vector-ref //inverse_/op (- (@st //i) 1)) 0)
           (cond ((or (= (vector-ref //inverse_/op (- (@st //i) 1))
                         //t_/greater)
                      (= (vector-ref //inverse_/op (- (@st //i) 1))
                         //t_/greater_/eq))
                  (set! //r
                    (@make (vector-ref
                             //reverse_/op
                             (- (vector-ref //inverse_/op (- (@st //i) 1)) 1))
                           '()
                           (list (list-ref //i (+ 1 2))
                                 (list-ref //i (+ 1 1))))))
                 (#t
                  (set! //r
                    (@make (vector-ref //inverse_/op (- (@st //i) 1))
                           '()
                           (@cs //i))))))
          ((= (@st //i) //t_/implies)
           (set! //r
             (@make //t_/and
                    '()
                    (list (@mth_de_morgan (list-ref //i (+ 1 1)))
                          (@mth_de_morgan_not (list-ref //i (+ 1 2)))))))
          (#t (set! //r (@make //t_/not '() (list //i)))))
    (set! funct-result //r)
    (set! //i //i-save)
    (set! //r //r-save)
    funct-result))

(define (@mth_sort_merge)
  (let ((/count-save /count))
    (set! /count 0)
    (@foreach_expn /foreach-maths-7 0 (@as_type) 0)
    (cond ((null? (@program)) (@new_program (@skips))))
    (@foreach_cond /foreach-maths-8 0 (@as_type) 0)
    (cond ((null? (@program)) (@new_program (@skips))))
    (set! /count /count-save)))

(define (@mth_sort_merge_item
         //i-par
         //s/t-par
         /count-par)
  (let ((/count-save /count)
        (//s/t-save //s/t)
        (//i-save //i)
        (//r-save //r)
        (/comps (@cs //i-par))
        (/new-save /new)
        (/n-save /n)
        (/re_sort 0)
        (/nums '())
        (/power (vector-ref //power_/op (- //s/t-par 1)))
        (/id (vector-ref //identity_/value (- //s/t-par 1)))
        (/zero (vector-ref //zero_/value (- //s/t-par 1)))
        (funct-result '()))
    (set! /count /count-par)
    (set! //s/t //s/t-par)
    (set! //i //i-par)
    (set! //r '())
    (set! /new '())
    (set! /n 0)
    (set! /fl_flag1 0)
    (let while-loop ()
      (cond ((= /fl_flag1 0)
             (begin
               (set! /re_sort 0)
               (cond ((< /count 2) (set! /comps (@mth_sort /comps))))
               (set! /new '())
               (let while-loop ()
                 (cond ((not (null? /comps))
                        (cond ((and (not (null? /id))
                                    (@equal? (car /comps) /id))
                               (set! /comps (cdr /comps)))
                              ((and (not (null? /zero))
                                    (@equal? (car /comps) /zero))
                               (set! /new (list /zero))
                               (set! /comps '()))
                              ((and (= //s/t //t_/times)
                                    (= (@st (car /comps)) //t_/invert)
                                    (= (@st (list-ref (car /comps) (+ 1 1)))
                                       //t_/number))
                               (let ((/num 1) (/denom 1))
                                 (let while-loop ()
                                   (cond ((and (not (null? /comps))
                                               (= (@st (car /comps))
                                                  //t_/invert)
                                               (= (@st (list-ref
                                                         (car /comps)
                                                         (+ 1 1)))
                                                  //t_/number))
                                          (begin
                                            (set! /denom
                                              (* /denom
                                                 (@v (list-ref
                                                       (car /comps)
                                                       (+ 1 1)))))
                                            (set! /comps (cdr /comps)))
                                          (while-loop))
                                         (#t #t)))
                                 (let while-loop ()
                                   (cond ((and (not (null? /comps))
                                               (= (@st (car /comps))
                                                  //t_/number))
                                          (begin
                                            (set! /num
                                              (* /num (@v (car /comps))))
                                            (set! /comps (cdr /comps)))
                                          (while-loop))
                                         (#t #t)))
                                 (cond ((= /num 1)
                                        (set! /new
                                          (cons (@make //t_/invert
                                                       '()
                                                       (list (@make //t_/number
                                                                    /denom
                                                                    '())))
                                                /new)))
                                       ((and (> (abs /num) (abs /denom))
                                             (not (= /denom 0))
                                             (= (modulo /num /denom) 0))
                                        (set! /new
                                          (cons (@make //t_/number
                                                       (/ /num /denom)
                                                       '())
                                                /new)))
                                       (#t
                                        (set! /new
                                          (cons (@make //t_/invert
                                                       '()
                                                       (list (@make //t_/number
                                                                    /denom
                                                                    '())))
                                                (cons (@make //t_/number
                                                             /num
                                                             '())
                                                      /new)))))))
                              ((= (@st (car /comps)) //t_/number)
                               (set! /nums '())
                               (let while-loop ()
                                 (cond ((and (not (null? /comps))
                                             (= (@st (car /comps)) //t_/number))
                                        (begin
                                          (set! /nums (cons (car /comps) /nums))
                                          (set! /comps (cdr /comps)))
                                        (while-loop))
                                       (#t #t)))
                               (cond ((= (if (vector? /nums)
                                           (vector-length /nums)
                                           (length /nums))
                                         1)
                                      (set! /new (concat /nums /new)))
                                     (#t
                                      (@edit)
                                      (@new_program (@make //s/t '() /nums))
                                      (@mth_evaluate)
                                      (cond ((not (@equal? (@program) /id))
                                             (set! /new
                                               (cons (@program) /new))))
                                      (@undo_edit))))
                              ((> /power 0)
                               (set! /n 1)
                               (let while-loop ()
                                 (cond ((and (not (null? (cdr /comps)))
                                             (@equal?
                                               (car /comps)
                                               (car (cdr /comps))))
                                        (begin
                                          (set! /n (+ /n 1))
                                          (set! /comps (cdr /comps)))
                                        (while-loop))
                                       (#t #t)))
                               (cond ((or (= /n 1) (= /power //s/t))
                                      (set! /new (cons (car /comps) /new)))
                                     (#t
                                      (set! /new
                                        (cons (@make /power
                                                     '()
                                                     (list (car /comps)
                                                           (@make //t_/number
                                                                  /n
                                                                  '())))
                                              /new))
                                      (set! /re_sort 1)))
                               (set! /comps (cdr /comps)))
                              (#t
                               (set! /new (cons (car /comps) /new))
                               (set! /comps (cdr /comps))))
                        (while-loop))
                       (#t #t)))
               (cond ((null? /new) (set! //r /id) (set! /fl_flag1 1))
                     ((= (if (vector? /new)
                           (vector-length /new)
                           (length /new))
                         1)
                      (set! //r (car /new))
                      (set! /fl_flag1 1))
                     ((= /re_sort 0)
                      (set! //r (@make //s/t '() (reverse /new)))
                      (set! /fl_flag1 1))
                     (#t
                      (set! /comps (reverse /new))
                      (set! /fl_flag1 0))))
             (while-loop))
            (#t #t)))
    (set! funct-result //r)
    (set! /count /count-save)
    (set! //s/t //s/t-save)
    (set! //i //i-save)
    (set! //r //r-save)
    (set! /new /new-save)
    (set! /n /n-save)
    funct-result))

(define (@mth_sort //l)
  (if (or (null? //l) (null? (cdr //l)))
    //l
    (if (= (if (vector? //l)
             (vector-length //l)
             (length //l))
           2)
      (if (@mth_lt?
            (let ((name //l))
              (if (vector? name)
                (vector-ref name (- 2 1))
                (list-ref name (- 2 1))))
            (let ((name //l))
              (if (vector? name)
                (vector-ref name (- 1 1))
                (list-ref name (- 1 1)))))
        (list (let ((name //l))
                (if (vector? name)
                  (vector-ref name (- 2 1))
                  (list-ref name (- 2 1))))
              (let ((name //l))
                (if (vector? name)
                  (vector-ref name (- 1 1))
                  (list-ref name (- 1 1)))))
        //l)
      (@mth_merge
        (@mth_sort
          (@sub_seg
            //l
            1
            (quotient
              (if (vector? //l)
                (vector-length //l)
                (length //l))
              2)))
        (@mth_sort
          (@final_seg
            //l
            (+ (quotient
                 (if (vector? //l)
                   (vector-length //l)
                   (length //l))
                 2)
               1)))))))

(define (@mth_merge //l1 //l2)
  (let ((//r-save //r) (funct-result '()))
    (set! //r '())
    (let while-loop ()
      (cond ((and (not (null? //l1)) (not (null? //l2)))
             (cond ((@mth_lt? (car //l2) (car //l1))
                    (set! //r (cons (car //l2) //r))
                    (set! //l2 (cdr //l2)))
                   (#t
                    (set! //r (cons (car //l1) //r))
                    (set! //l1 (cdr //l1))))
             (while-loop))
            (#t #t)))
    (let while-loop ()
      (cond ((not (null? //l1))
             (begin
               (set! //r (cons (car //l1) //r))
               (set! //l1 (cdr //l1)))
             (while-loop))
            (#t #t)))
    (let while-loop ()
      (cond ((not (null? //l2))
             (begin
               (set! //r (cons (car //l2) //r))
               (set! //l2 (cdr //l2)))
             (while-loop))
            (#t #t)))
    (set! funct-result (reverse //r))
    (set! //r //r-save)
    funct-result))

(define (@mth_lt? /x-par /y)
  (let ((/x-save /x) (//o/k 0) (funct-result '()))
    (set! /x /x-par)
    (cond ((> (@total_size /x) (@total_size /y))
           (set! //o/k 1))
          ((< (@total_size /x) (@total_size /y))
           (set! //o/k 0))
          ((< (vector-ref //mth_/ord (- (@st /x) 1))
              (vector-ref //mth_/ord (- (@st /y) 1)))
           (set! //o/k 1))
          ((> (vector-ref //mth_/ord (- (@st /x) 1))
              (vector-ref //mth_/ord (- (@st /y) 1)))
           (set! //o/k 0))
          ((< (@size /x) (@size /y)) (set! //o/k 1))
          ((> (@size /x) (@size /y)) (set! //o/k 0))
          ((@has_value_type? (@st /x))
           (cond ((or (= (@st /x) //t_/number)
                      (= (@st /x) //t_/exit))
                  (cond ((< (@v /x) (@v /y)) (set! //o/k 1))))
                 ((or (= (@st /x) //t_/string)
                      (= (@st /x) //t_/comment))
                  (cond ((string<? (@v /x) (@v /y)) (set! //o/k 1))))
                 ((string<?
                    (@n_string (@v /x))
                    (@n_string (@v /y)))
                  (set! //o/k 1))))
          ((not (@cs? /x)) (set! //o/k 1))
          ((not (@cs? /y)) (set! //o/k 0))
          ((@mth_lt?
             (list-ref /x (+ 1 1))
             (list-ref /y (+ 1 1)))
           (set! //o/k 1))
          ((@equal?
             (list-ref /x (+ 1 1))
             (list-ref /y (+ 1 1)))
           (let ((/c1 (cdr (@cs /x))) (/c2 (cdr (@cs /y))))
             (set! //o/k 0)
             (let while-loop ()
               (cond ((not (null? /c1))
                      (cond ((@mth_lt? (car /c1) (car /c2))
                             (set! //o/k 1)
                             (set! /c1 '()))
                            ((@equal? (car /c1) (car /c2))
                             (set! /c1 (cdr /c1))
                             (set! /c2 (cdr /c2)))
                            (#t (set! //o/k 0) (set! /c1 '())))
                      (while-loop))
                     (#t #t)))))
          (#t (set! //o/k 0)))
    (set! funct-result (= //o/k 1))
    (set! /x /x-save)
    funct-result))

(define (@mth_duplicate_relations)
  (let ((/top (@st (@i)))
        (/comp-save /comp)
        (/rels '())
        (/rel-save /rel)
        (/new-save /new)
        (/same-save /same)
        (/diff-save /diff)
        (/comps (@cs (@i)))
        (/change-save /change))
    (set! /comp '())
    (set! /rel '())
    (set! /new '())
    (set! /same '())
    (set! /diff '())
    (set! /change 0)
    (cond ((= /top //t_/and)
           (set! /same //mth_/true)
           (set! /diff //mth_/false))
          (#t
           (set! /same //mth_/false)
           (set! /diff //mth_/true)))
    (let ((var-save /comp) (seq-save /comps))
      (if (vector? seq-save)
        (set! seq-save (vector-elts seq-save)))
      (let for-in-loop ((for-tmp seq-save))
        (cond ((not (null? for-tmp))
               (set! /comp (car for-tmp))
               (cond ((or (= (@st /comp) //t_/equal)
                          (= (@st /comp) //t_/not_/equal)
                          (= (@st /comp) //t_/less)
                          (= (@st /comp) //t_/less_/eq))
                      (set! /rels (cons /comp /rels))))
               (for-in-loop (cdr for-tmp)))
              (#t #t)))
      (set! /comp var-save))
    (cond ((not (null? /rels))
           (@edit)
           (let ((var-save /rel) (seq-save /rels))
             (if (vector? seq-save)
               (set! seq-save (vector-elts seq-save)))
             (let for-in-loop ((for-tmp seq-save))
               (cond ((not (null? for-tmp))
                      (set! /rel (car for-tmp))
                      (begin
                        (set! /new '())
                        (let ((var-save /comp) (seq-save /comps))
                          (if (vector? seq-save)
                            (set! seq-save (vector-elts seq-save)))
                          (let for-in-loop ((for-tmp seq-save))
                            (cond ((not (null? for-tmp))
                                   (set! /comp (car for-tmp))
                                   (cond ((@equal? /comp /rel)
                                          (set! /new (cons /comp /new)))
                                         ((= (@st /comp)
                                             (vector-ref
                                               //reverse_/op
                                               (- (@st /rel) 1)))
                                          (cond ((and (@equal?
                                                        (list-ref /comp (+ 1 2))
                                                        (list-ref /rel (+ 1 1)))
                                                      (@equal?
                                                        (list-ref /comp (+ 1 1))
                                                        (list-ref
                                                          /rel
                                                          (+ 1 2))))
                                                 (set! /change 1)
                                                 (set! /new (cons /same /new)))
                                                (#t
                                                 (set! /new
                                                   (cons /comp /new)))))
                                         ((= (@st /comp)
                                             (vector-ref
                                               //inverse_/op
                                               (- (@st /rel) 1)))
                                          (cond ((and (@equal?
                                                        (list-ref /comp (+ 1 2))
                                                        (list-ref /rel (+ 1 2)))
                                                      (@equal?
                                                        (list-ref /comp (+ 1 1))
                                                        (list-ref
                                                          /rel
                                                          (+ 1 1))))
                                                 (set! /change 1)
                                                 (set! /new (cons /diff /new)))
                                                (#t
                                                 (set! /new
                                                   (cons /comp /new)))))
                                         ((= (@st /comp)
                                             (vector-ref
                                               //inverse_/op
                                               (- (vector-ref
                                                    //reverse_/op
                                                    (- (@st /rel) 1))
                                                  1)))
                                          (cond ((and (@equal?
                                                        (list-ref /comp (+ 1 2))
                                                        (list-ref /rel (+ 1 1)))
                                                      (@equal?
                                                        (list-ref /comp (+ 1 1))
                                                        (list-ref
                                                          /rel
                                                          (+ 1 2))))
                                                 (set! /change 1)
                                                 (set! /new (cons /diff /new)))
                                                (#t
                                                 (set! /new
                                                   (cons /comp /new)))))
                                         ((and (or (= (@st /comp) //t_/equal)
                                                   (= (@st /comp)
                                                      //t_/not_/equal)
                                                   (= (@st /comp) //t_/less)
                                                   (= (@st /comp)
                                                      //t_/less_/eq))
                                               (@equal?
                                                 (list-ref /comp (+ 1 1))
                                                 (list-ref /rel (+ 1 1)))
                                               (@equal?
                                                 (list-ref /comp (+ 1 2))
                                                 (list-ref /rel (+ 1 2))))
                                          (set! /new
                                            (cons (@mth_same_args
                                                    /top
                                                    /comp
                                                    /rel
                                                    0)
                                                  /new))
                                          (cond ((not (@equal?
                                                        (car /new)
                                                        /comp))
                                                 (set! /change 1))))
                                         ((and (or (= (@st /comp) //t_/equal)
                                                   (= (@st /comp)
                                                      //t_/not_/equal)
                                                   (= (@st /comp) //t_/less)
                                                   (= (@st /comp)
                                                      //t_/less_/eq))
                                               (@equal?
                                                 (list-ref /comp (+ 1 1))
                                                 (list-ref /rel (+ 1 2)))
                                               (@equal?
                                                 (list-ref /comp (+ 1 2))
                                                 (list-ref /rel (+ 1 1))))
                                          (set! /new
                                            (cons (@mth_same_args
                                                    /top
                                                    /comp
                                                    /rel
                                                    1)
                                                  /new))
                                          (cond ((not (@equal?
                                                        (car /new)
                                                        /comp))
                                                 (set! /change 1))))
                                         ((or (= (@st /comp) //t_/or)
                                              (= (@st /comp) //t_/and))
                                          (set! /change
                                            (@mth_duplicate_relations_sub
                                              /comp
                                              /rel
                                              /change))
                                          (set! /new (cons (@program) /new)))
                                         (#t (set! /new (cons /comp /new))))
                                   (for-in-loop (cdr for-tmp)))
                                  (#t #t)))
                          (set! /comp var-save))
                        (set! /comps (reverse /new)))
                      (for-in-loop (cdr for-tmp)))
                     (#t #t)))
             (set! /rel var-save))
           (@undo_edit)
           (cond ((= /change 1)
                  (@paste_over (@make /top '() /comps))
                  (@mth_sort_merge)))))
    (set! /comp /comp-save)
    (set! /rel /rel-save)
    (set! /new /new-save)
    (set! /same /same-save)
    (set! /diff /diff-save)
    (set! /change /change-save)))

(define (@mth_duplicate_relations_sub
         /comp-par
         /rel-par
         /change-par)
  (let ((/change-save /change)
        (/rel-save /rel)
        (/comp-save /comp)
        (funct-result '()))
    (set! /change /change-par)
    (set! /rel /rel-par)
    (set! /comp /comp-par)
    (@new_program /comp)
    (@foreach_cond /foreach-maths-9 0 (@as_type) 0)
    (cond ((null? (@program)) (@new_program (@skips))))
    (set! funct-result /change)
    (set! /change /change-save)
    (set! /rel /rel-save)
    (set! /comp /comp-save)
    funct-result))

(define (@mth_same_args /top /comp-par /rel-par /rev)
  (let ((/rel-save /rel)
        (/comp-save /comp)
        (//r-save //r)
        (funct-result '()))
    (set! /rel /rel-par)
    (set! /comp /comp-par)
    (set! //r /comp-par)
    (cond ((= /top //t_/and)
           (cond ((= (@st /rel) //t_/equal)
                  (cond ((or (= (@st /comp) //t_/not_/equal)
                             (= (@st /comp) //t_/less))
                         (set! //r //mth_/false))
                        (#t (set! //r //mth_/true))))
                 ((= (@st /rel) //t_/not_/equal))
                 ((and (= (@st /rel) //t_/less) (= /rev 0))
                  (cond ((= (@st /comp) //t_/equal)
                         (set! //r //mth_/false))
                        ((= (@st /comp) //t_/not_/equal)
                         (set! //r //mth_/true))
                        ((= (@st /comp) //t_/less_/eq)
                         (set! //r //mth_/true))))
                 ((= (@st /rel) //t_/less_/eq)
                  (cond ((= (@st /comp) //t_/not_/equal)
                         (set! //r
                           (@make //t_/less
                                  '()
                                  (list (list-ref /rel (+ 1 1))
                                        (list-ref /rel (+ 1 2))))))
                        ((and (= (@st /comp) //t_/less_/eq) (= /rev 1))
                         (set! //r
                           (@make //t_/equal
                                  '()
                                  (list (list-ref /rel (+ 1 1))
                                        (list-ref /rel (+ 1 2))))))))
                 ((and (= (@st /rel) //t_/less) (= /rev 1))
                  (cond ((= (@st /comp) //t_/equal)
                         (set! //r //mth_/false))
                        ((= (@st /comp) //t_/not_/equal)
                         (set! //r //mth_/true))
                        ((= (@st /comp) //t_/less)
                         (set! //r //mth_/false))
                        ((= (@st /comp) //t_/less_/eq)
                         (set! //r //mth_/false))))))
          (#t
           (cond ((= (@st /comp) //t_/equal))
                 ((= (@st /rel) //t_/not_/equal)
                  (cond ((= (@st /comp) //t_/equal)
                         (set! //r //mth_/true))
                        ((= (@st /comp) //t_/less)
                         (set! //r //mth_/false))
                        ((= (@st /comp) //t_/less_/eq)
                         (set! //r //mth_/true))))
                 ((and (= (@st /rel) //t_/less) (= /rev 0))
                  (cond ((= (@st /comp) //t_/equal)
                         (set! //r
                           (@make //t_/less_/eq
                                  '()
                                  (list (list-ref /rev (+ 1 1))
                                        (list-ref /rev (+ 1 2))))))))
                 ((and (= (@st /rel) //t_/less_/eq) (= /rev 0))
                  (cond ((= (@st /comp) //t_/equal)
                         (set! //r //mth_/false))
                        ((= (@st /comp) //t_/not_/equal)
                         (set! //r //mth_/true))
                        ((= (@st /comp) //t_/less)
                         (set! //r //mth_/false))))
                 ((and (= (@st /rel) //t_/less_/eq) (= /rev 1))
                  (cond ((= (@st /comp) //t_/equal)
                         (set! //r //mth_/false))
                        (#t (set! //r //mth_/true)))))))
    (set! funct-result //r)
    (set! /rel /rel-save)
    (set! /comp /comp-save)
    (set! //r //r-save)
    funct-result))

(define (@mth_known_value1 //budget-par)
  (let ((//budget-save //budget))
    (set! //budget //budget-par)
    (let ((/comp-save /comp)
          (/vars-save /vars)
          (/vals-save /vals)
          (/done 0)
          (//s/t-save //s/t))
      (set! /comp '())
      (set! /vars '())
      (set! /vals '())
      (set! //s/t 0)
      (let ((var-save /comp) (seq-save (@cs (@i))))
        (if (vector? seq-save)
          (set! seq-save (vector-elts seq-save)))
        (let for-in-loop ((for-tmp seq-save))
          (cond ((not (null? for-tmp))
                 (set! /comp (car for-tmp))
                 (cond ((= (@st /comp) //t_/equal)
                        (cond ((and (or (= (@st (list-ref /comp (+ 1 2)))
                                           //t_/number)
                                        (= (@st (list-ref /comp (+ 1 2)))
                                           //t_/string))
                                    (> (@mth_count_occs
                                         (list-ref /comp (+ 1 1)))
                                       1))
                               (set! /vars
                                 (cons (list-ref /comp (+ 1 1)) /vars))
                               (set! /vals
                                 (cons (list-ref /comp (+ 1 2)) /vals))))))
                 (for-in-loop (cdr for-tmp)))
                (#t #t)))
        (set! /comp var-save))
      (let while-loop ()
        (cond ((and (not (null? /vars)) (= /done 0))
               (begin
                 (@edit)
                 (@foreach_expn /foreach-maths-10 0 (@as_type) 0)
                 (cond ((null? (@program)) (@new_program (@skips))))
                 (set! //s/t
                   (@st (@simplify (@i) (quotient //budget 2))))
                 (cond ((= //s/t //t_/true)
                        (@paste_over
                          (@make //t_/equal
                                 '()
                                 (list (car /vars) (car /vals))))
                        (set! /done 1)
                        (@end_edit))
                       ((= //s/t //t_/false)
                        (@paste_over (@make //t_/false '() '()))
                        (set! /done 1)
                        (@end_edit))
                       (#t (@undo_edit)))
                 (set! /vals (cdr /vals))
                 (set! /vars (cdr /vars)))
               (while-loop))
              (#t #t)))
      (set! /comp /comp-save)
      (set! /vars /vars-save)
      (set! /vals /vals-save)
      (set! //s/t //s/t-save))
    (set! //budget //budget-save)))

(define (@mth_known_value2 //budget-par)
  (let ((//budget-save //budget))
    (set! //budget //budget-par)
    (let ((/comp-save /comp)
          (/vars-save /vars)
          (/vals-save /vals)
          (/done 0)
          (//s/t-save //s/t))
      (set! /comp '())
      (set! /vars '())
      (set! /vals '())
      (set! //s/t 0)
      (let ((var-save /comp) (seq-save (@cs (@i))))
        (if (vector? seq-save)
          (set! seq-save (vector-elts seq-save)))
        (let for-in-loop ((for-tmp seq-save))
          (cond ((not (null? for-tmp))
                 (set! /comp (car for-tmp))
                 (cond ((= (@st /comp) //t_/not_/equal)
                        (cond ((and (or (= (@st (list-ref /comp (+ 1 2)))
                                           //t_/number)
                                        (= (@st (list-ref /comp (+ 1 2)))
                                           //t_/string))
                                    (> (@mth_count_occs
                                         (list-ref /comp (+ 1 1)))
                                       1))
                               (set! /vars
                                 (cons (list-ref /comp (+ 1 1)) /vars))
                               (set! /vals
                                 (cons (list-ref /comp (+ 1 2)) /vals))))))
                 (for-in-loop (cdr for-tmp)))
                (#t #t)))
        (set! /comp var-save))
      (let while-loop ()
        (cond ((and (not (null? /vars)) (= /done 0))
               (begin
                 (@edit)
                 (@foreach_expn /foreach-maths-11 0 (@as_type) 0)
                 (cond ((null? (@program)) (@new_program (@skips))))
                 (set! //s/t
                   (@st (@simplify (@i) (quotient //budget 2))))
                 (cond ((= //s/t //t_/true)
                        (@paste_over (@make //t_/true '() '()))
                        (set! /done 1)
                        (@end_edit))
                       ((= //s/t //t_/false)
                        (@paste_over
                          (@make //t_/not_/equal
                                 '()
                                 (list (car /vars) (car /vals))))
                        (set! /done 1)
                        (@end_edit))
                       (#t (@undo_edit)))
                 (set! /vals (cdr /vals))
                 (set! /vars (cdr /vars)))
               (while-loop))
              (#t #t)))
      (set! /comp /comp-save)
      (set! /vars /vars-save)
      (set! /vals /vals-save)
      (set! //s/t //s/t-save))
    (set! //budget //budget-save)))

(define (@mth_known_value3 //budget-par)
  (let ((//budget-save //budget))
    (set! //budget //budget-par)
    (let ((/comp-save /comp)
          (/comps (@cs (@i)))
          (/vars-save /vars)
          (/vals-save /vals)
          (/index '())
          (/n-save /n)
          (/i 0)
          (/done 0)
          (//s/t-save //s/t)
          (/var-save /var)
          (/val-save /val))
      (set! /comp '())
      (set! /vars '())
      (set! /vals '())
      (set! /n 0)
      (set! //s/t 0)
      (set! /var '())
      (set! /val '())
      (let ((var-save /comp) (seq-save /comps))
        (if (vector? seq-save)
          (set! seq-save (vector-elts seq-save)))
        (let for-in-loop ((for-tmp seq-save))
          (cond ((not (null? for-tmp))
                 (set! /comp (car for-tmp))
                 (begin
                   (set! /n (+ /n 1))
                   (cond ((= (@st /comp) //t_/not_/equal)
                          (cond ((and (or (= (@st (list-ref /comp (+ 1 2)))
                                             //t_/number)
                                          (= (@st (list-ref /comp (+ 1 2)))
                                             //t_/string))
                                      (> (@mth_count_occs
                                           (list-ref /comp (+ 1 1)))
                                         1))
                                 (set! /vars
                                   (cons (list-ref /comp (+ 1 1)) /vars))
                                 (set! /vals
                                   (cons (list-ref /comp (+ 1 2)) /vals))
                                 (set! /index (cons /n /index)))))))
                 (for-in-loop (cdr for-tmp)))
                (#t #t)))
        (set! /comp var-save))
      (@edit)
      (let while-loop ()
        (cond ((and (not (null? /vars)) (= /done 0))
               (begin
                 (set! /var (car /vars))
                 (set! /val (car /vals))
                 (set! /i (car /index))
                 (set! /vars (cdr /vars))
                 (set! /vals (cdr /vals))
                 (set! /index (cdr /index))
                 (set! /n 0)
                 (let ((var-save /comp) (seq-save /comps))
                   (if (vector? seq-save)
                     (set! seq-save (vector-elts seq-save)))
                   (let for-in-loop ((for-tmp seq-save))
                     (cond ((not (null? for-tmp))
                            (set! /comp (car for-tmp))
                            (begin
                              (set! /n (+ /n 1))
                              (cond ((not (equal? /n /i))
                                     (@new_program /comp)
                                     (cond ((> (@mth_count_occs /var) 0)
                                            (@foreach_expn
                                              /foreach-maths-12
                                              0
                                              (@as_type)
                                              0)
                                            (cond ((null? (@program))
                                                   (@new_program (@skips))))
                                            (set! //s/t
                                              (@st (@simplify
                                                     (@i)
                                                     (quotient //budget 2))))
                                            (cond ((= //s/t //t_/false)
                                                   (set! /done 1))))))))
                            (for-in-loop (cdr for-tmp)))
                           (#t #t)))
                   (set! /comp var-save)))
               (while-loop))
              (#t #t)))
      (@undo_edit)
      (cond ((= /done 1)
             (@down_to /i)
             (@clever_delete)
             (cond ((@up?) (@up)))))
      (set! /comp /comp-save)
      (set! /vars /vars-save)
      (set! /vals /vals-save)
      (set! /n /n-save)
      (set! //s/t //s/t-save)
      (set! /var /var-save)
      (set! /val /val-save))
    (set! //budget //budget-save)))

(define (@mth_known_value4 //budget-par)
  (let ((//budget-save //budget))
    (set! //budget //budget-par)
    (let ((/comp-save /comp)
          (/comps (@cs (@i)))
          (/vars-save /vars)
          (/vals-save /vals)
          (/index '())
          (/n-save /n)
          (/i 0)
          (/done 0)
          (//s/t-save //s/t)
          (/var-save /var)
          (/val-save /val))
      (set! /comp '())
      (set! /vars '())
      (set! /vals '())
      (set! /n 0)
      (set! //s/t 0)
      (set! /var '())
      (set! /val '())
      (let ((var-save /comp) (seq-save /comps))
        (if (vector? seq-save)
          (set! seq-save (vector-elts seq-save)))
        (let for-in-loop ((for-tmp seq-save))
          (cond ((not (null? for-tmp))
                 (set! /comp (car for-tmp))
                 (begin
                   (set! /n (+ /n 1))
                   (cond ((= (@st /comp) //t_/equal)
                          (cond ((and (or (= (@st (list-ref /comp (+ 1 2)))
                                             //t_/number)
                                          (= (@st (list-ref /comp (+ 1 2)))
                                             //t_/string))
                                      (> (@mth_count_occs
                                           (list-ref /comp (+ 1 1)))
                                         1))
                                 (set! /vars
                                   (cons (list-ref /comp (+ 1 1)) /vars))
                                 (set! /vals
                                   (cons (list-ref /comp (+ 1 2)) /vals))
                                 (set! /index (cons /n /index)))))))
                 (for-in-loop (cdr for-tmp)))
                (#t #t)))
        (set! /comp var-save))
      (@edit)
      (let while-loop ()
        (cond ((and (not (null? /vars)) (= /done 0))
               (begin
                 (set! /var (car /vars))
                 (set! /val (car /vals))
                 (set! /i (car /index))
                 (set! /vars (cdr /vars))
                 (set! /vals (cdr /vals))
                 (set! /index (cdr /index))
                 (set! /n 0)
                 (let ((var-save /comp) (seq-save /comps))
                   (if (vector? seq-save)
                     (set! seq-save (vector-elts seq-save)))
                   (let for-in-loop ((for-tmp seq-save))
                     (cond ((not (null? for-tmp))
                            (set! /comp (car for-tmp))
                            (begin
                              (set! /n (+ /n 1))
                              (cond ((not (equal? /n /i))
                                     (@new_program /comp)
                                     (cond ((> (@mth_count_occs /var) 0)
                                            (@foreach_expn
                                              /foreach-maths-13
                                              0
                                              (@as_type)
                                              0)
                                            (cond ((null? (@program))
                                                   (@new_program (@skips))))
                                            (set! //s/t
                                              (@st (@simplify
                                                     (@i)
                                                     (quotient //budget 2))))
                                            (cond ((= //s/t //t_/true)
                                                   (set! /done 1))))))))
                            (for-in-loop (cdr for-tmp)))
                           (#t #t)))
                   (set! /comp var-save)))
               (while-loop))
              (#t #t)))
      (@undo_edit)
      (cond ((= /done 1)
             (@down_to /i)
             (@clever_delete)
             (cond ((@up?) (@up)))))
      (set! /comp /comp-save)
      (set! /vars /vars-save)
      (set! /vals /vals-save)
      (set! /n /n-save)
      (set! //s/t //s/t-save)
      (set! /var /var-save)
      (set! /val /val-save))
    (set! //budget //budget-save)))

(define (@mth_common_components //budget-par)
  (let ((//budget-save //budget))
    (set! //budget //budget-par)
    (let ((/main (@st (@i)))
          (/sub (@st (list-ref (@i) (+ 1 1))))
          (/comps '())
          (/delete '())
          (/comp1 '())
          (/comp2 '())
          (/elts '()))
      (@edit)
      (@mth_sort_merge)
      (cond ((or (not (= (@st (@i)) /main))
                 (null? (@cs (@i))))
             (@undo_edit))
            (#t
             (set! /comps (@cs (@i)))
             (let while-loop ()
               (cond ((not (null? (cdr /comps)))
                      (begin
                        (set! /comp1 (car /comps))
                        (set! /comps (cdr /comps))
                        (set! /elts (@elements /comp1))
                        (let ((var-save /comp2) (seq-save /comps))
                          (if (vector? seq-save)
                            (set! seq-save (vector-elts seq-save)))
                          (let for-in-loop ((for-tmp seq-save))
                            (cond ((not (null? for-tmp))
                                   (set! /comp2 (car for-tmp))
                                   (cond ((= (@st /comp2) /sub)
                                          (cond ((and (@set_subset?
                                                        (@elements /comp2)
                                                        /elts)
                                                      (@mth_subset?
                                                        (@cs /comp2)
                                                        (@cs /comp1)))
                                                 (set! /delete
                                                   (cons /comp1 /delete)))
                                                ((and (@set_subset?
                                                        /elts
                                                        (@elements /comp2))
                                                      (@mth_subset?
                                                        (@cs /comp1)
                                                        (@cs /comp2)))
                                                 (set! /delete
                                                   (cons /comp2 /delete))))))
                                   (for-in-loop (cdr for-tmp)))
                                  (#t #t)))
                          (set! /comp2 var-save)))
                      (while-loop))
                     (#t #t)))
             (cond ((null? /delete) (@undo_edit))
                   (#t
                    (@end_edit)
                    (let ((var-save /comp1) (seq-save /delete))
                      (if (vector? seq-save)
                        (set! seq-save (vector-elts seq-save)))
                      (let for-in-loop ((for-tmp seq-save))
                        (cond ((not (null? for-tmp))
                               (set! /comp1 (car for-tmp))
                               (begin
                                 (@down)
                                 (set! /fl_flag1 0)
                                 (let while-loop ()
                                   (cond ((= /fl_flag1 0)
                                          (cond ((@equal? (@i) /comp1)
                                                 (@delete)
                                                 (set! /fl_flag1 1))
                                                ((@right?)
                                                 (@right)
                                                 (set! /fl_flag1 0))
                                                (#t (set! /fl_flag1 1)))
                                          (while-loop))
                                         (#t #t)))
                                 (@up)
                                 (cond ((not (@cs? (@i)))
                                        (error "BUG in @Mth_Common_Components!!!"))))
                               (for-in-loop (cdr for-tmp)))
                              (#t #t)))
                      (set! /comp1 var-save)))))))
    (set! //budget //budget-save)))

(define (@mth_subset? //l1 //l2)
  (= (@mth_subset_sub //l1 //l2) 1))

(define (@mth_subset_sub //l1 //l2)
  (if (null? //l1)
    1
    (if (null? //l2)
      0
      (if (@equal? (car //l1) (car //l2))
        (@mth_subset_sub (cdr //l1) (cdr //l2))
        (if (@mth_lt? (car //l1) (car //l2))
          0
          (@mth_subset_sub //l1 (cdr //l2)))))))

(define (@mth_count_occs //i-par)
  (let ((//i-save //i)
        (//r-save //r)
        (funct-result '()))
    (set! //i //i-par)
    (set! //r 0)
    (@foreach_expn /foreach-maths-14 0 (@as_type) 0)
    (cond ((null? (@program)) (@new_program (@skips))))
    (set! funct-result //r)
    (set! //i //i-save)
    (set! //r //r-save)
    funct-result))

(define (@mth_expand //budget-par)
  (let ((//budget-save //budget))
    (set! //budget //budget-par)
    (@foreach_expn /foreach-maths-15 0 (@as_type) 0)
    (cond ((null? (@program)) (@new_program (@skips))))
    (cond ((= (@gt (@i)) //t_/condition)
           (@foreach_cond /foreach-maths-16 0 (@as_type) 0)
           (cond ((null? (@program)) (@new_program (@skips))))))
    (set! //budget //budget-save)))

(define (@mth_multiply /mul /add //budget-par)
  (let ((//budget-save //budget))
    (set! //budget //budget-par)
    (let ((//l1 (@cs (@i)))
          (//l2 '())
          (/new-save /new)
          (/x-save /x)
          (/y '()))
      (set! /new '())
      (set! /x '())
      (@right)
      (cond ((< (* (if (vector? //l1)
                     (vector-length //l1)
                     (length //l1))
                   (@size (@i)))
                (quotient //budget 2))
             (set! //l2 (@cs (@i)))
             (let ((var-save /x) (seq-save //l1))
               (if (vector? seq-save)
                 (set! seq-save (vector-elts seq-save)))
               (let for-in-loop ((for-tmp seq-save))
                 (cond ((not (null? for-tmp))
                        (set! /x (car for-tmp))
                        (let ((var-save /y) (seq-save //l2))
                          (if (vector? seq-save)
                            (set! seq-save (vector-elts seq-save)))
                          (let for-in-loop ((for-tmp seq-save))
                            (cond ((not (null? for-tmp))
                                   (set! /y (car for-tmp))
                                   (cond ((= (@st /x) /mul)
                                          (set! /new
                                            (cons (@make /mul
                                                         '()
                                                         (concat
                                                           (@cs /x)
                                                           (list /y)))
                                                  /new)))
                                         (#t
                                          (set! /new
                                            (cons (@make /mul '() (list /x /y))
                                                  /new))))
                                   (for-in-loop (cdr for-tmp)))
                                  (#t #t)))
                          (set! /y var-save))
                        (for-in-loop (cdr for-tmp)))
                       (#t #t)))
               (set! /x var-save))
             (@left)
             (@delete)
             (@paste_over (@make /add '() (reverse /new)))))
      (set! /new /new-save)
      (set! /x /x-save))
    (set! //budget //budget-save)))

(define (@mth_factorise //budget-par)
  (let ((//budget-save //budget))
    (set! //budget //budget-par)
    (let ((/orig '()))
      (set! /orig (@i))
      (@foreach_expn /foreach-maths-17 0 (@as_type) 0)
      (cond ((null? (@program)) (@new_program (@skips))))
      (@foreach_cond /foreach-maths-18 0 (@as_type) 0)
      (cond ((null? (@program)) (@new_program (@skips))))
      (let while-loop ()
        (cond ((not (@equal? (@i) /orig))
               (begin
                 (set! /orig (@i))
                 (@foreach_expn /foreach-maths-19 0 (@as_type) 0)
                 (cond ((null? (@program)) (@new_program (@skips))))
                 (@foreach_cond /foreach-maths-20 0 (@as_type) 0)
                 (cond ((null? (@program)) (@new_program (@skips)))))
               (while-loop))
              (#t #t))))
    (set! //budget //budget-save)))

(define (@mth_occs /elt /list)
  (let ((//r 0))
    (let while-loop ()
      (cond ((not (null? /list))
             (begin
               (cond ((equal? /elt (car /list)) (set! //r (+ //r 1))))
               (set! /list (cdr /list)))
             (while-loop))
            (#t #t)))
    //r))

(define (@mth_factor //plus //times)
  (let ((/factors '())
        (/common '())
        (/occs 0)
        (/max 0)
        (/comp-save /comp))
    (set! /comp '())
    (let ((var-save /comp) (seq-save (@cs (@i))))
      (if (vector? seq-save)
        (set! seq-save (vector-elts seq-save)))
      (let for-in-loop ((for-tmp seq-save))
        (cond ((not (null? for-tmp))
               (set! /comp (car for-tmp))
               (cond ((= (@st /comp) //times)
                      (set! /factors (concat (@cs /comp) /factors))))
               (for-in-loop (cdr for-tmp)))
              (#t #t)))
      (set! /comp var-save))
    (set! /factors (@mth_sort /factors))
    (let while-loop ()
      (cond ((not (null? /factors))
             (begin
               (set! /occs 1)
               (let while-loop ()
                 (cond ((and (not (null? (cdr /factors)))
                             (@equal? (car /factors) (car (cdr /factors))))
                        (begin
                          (set! /occs (+ /occs 1))
                          (cond ((> /occs /max)
                                 (set! /common (car /factors))
                                 (set! /max /occs)))
                          (set! /factors (cdr /factors)))
                        (while-loop))
                       (#t #t)))
               (set! /factors (cdr /factors)))
             (while-loop))
            (#t #t)))
    (cond ((>= /max 2)
           (let ((/new-save /new)
                 (/sub '())
                 (/newsub '())
                 (/newcomp '())
                 (/done 0))
             (set! /new '())
             (let ((var-save /comp) (seq-save (@cs (@i))))
               (if (vector? seq-save)
                 (set! seq-save (vector-elts seq-save)))
               (let for-in-loop ((for-tmp seq-save))
                 (cond ((not (null? for-tmp))
                        (set! /comp (car for-tmp))
                        (cond ((= (@st /comp) //times)
                               (set! /newcomp '())
                               (set! /done 0)
                               (let ((var-save /sub) (seq-save (@cs /comp)))
                                 (if (vector? seq-save)
                                   (set! seq-save (vector-elts seq-save)))
                                 (let for-in-loop ((for-tmp seq-save))
                                   (cond ((not (null? for-tmp))
                                          (set! /sub (car for-tmp))
                                          (cond ((and (= /done 0)
                                                      (@equal? /common /sub))
                                                 (cond ((not (equal?
                                                               (vector-ref
                                                                 //power_/op
                                                                 (- //times 1))
                                                               //times))
                                                        (set! /done 1))))
                                                (#t
                                                 (set! /newcomp
                                                   (cons /sub /newcomp))))
                                          (for-in-loop (cdr for-tmp)))
                                         (#t #t)))
                                 (set! /sub var-save))
                               (cond ((= (if (vector? /newcomp)
                                           (vector-length /newcomp)
                                           (length /newcomp))
                                         0)
                                      #t)
                                     ((= (if (vector? /newcomp)
                                           (vector-length /newcomp)
                                           (length /newcomp))
                                         1)
                                      (set! /newsub (concat /newcomp /newsub)))
                                     ((< (if (vector? /newcomp)
                                           (vector-length /newcomp)
                                           (length /newcomp))
                                         (@size /comp))
                                      (set! /newsub
                                        (cons (@make //times
                                                     '()
                                                     (reverse /newcomp))
                                              /newsub)))
                                     (#t (set! /new (cons /comp /new)))))
                              (#t (set! /new (cons /comp /new))))
                        (for-in-loop (cdr for-tmp)))
                       (#t #t)))
               (set! /comp var-save))
             (cond ((= (if (vector? /newsub)
                         (vector-length /newsub)
                         (length /newsub))
                       0)
                    #t)
                   ((= (if (vector? /newsub)
                         (vector-length /newsub)
                         (length /newsub))
                       1)
                    (set! /newsub
                      (@make //times
                             '()
                             (@mth_sort
                               (list /common
                                     (let ((name /newsub))
                                       (if (vector? name)
                                         (vector-ref name (- 1 1))
                                         (list-ref name (- 1 1)))))))))
                   (#t
                    (set! /newsub
                      (@make //times
                             '()
                             (@mth_sort
                               (list /common
                                     (@make //plus
                                            '()
                                            (@mth_sort /newsub))))))))
             (cond ((not (null? /newsub))
                    (cond ((null? /new) (@paste_over /newsub))
                          (#t
                           (@paste_over
                             (@make //plus
                                    '()
                                    (@mth_sort (cons /newsub /new))))))))
             (set! /new /new-save))))
    (set! /comp /comp-save)))

(define (@mth_prettify)
  (let ((/count-save /count))
    (set! /count 0)
    (@foreach_expn /foreach-maths-21 0 (@as_type) 0)
    (cond ((null? (@program)) (@new_program (@skips))))
    (cond ((= (@gt (@i)) //t_/condition)
           (cond ((or (= (@st (@i)) //t_/and)
                      (= (@st (@i)) //t_/or))
                  (let ((var-save /comp) (seq-save (@cs (@i))))
                    (if (vector? seq-save)
                      (set! seq-save (vector-elts seq-save)))
                    (let for-in-loop ((for-tmp seq-save))
                      (cond ((not (null? for-tmp))
                             (set! /comp (car for-tmp))
                             (cond ((@unsafe_test? /comp)
                                    (set! /count (+ /count 1))))
                             (for-in-loop (cdr for-tmp)))
                            (#t #t)))
                    (set! /comp var-save))))))
    (cond ((and (= (@gt (@i)) //t_/condition) (< /count 2))
           (@foreach_cond /foreach-maths-22 0 (@as_type) 0)
           (cond ((null? (@program)) (@new_program (@skips))))))
    (@foreach_expn /foreach-maths-23 0 (@as_type) 0)
    (cond ((null? (@program)) (@new_program (@skips))))
    (set! /count /count-save)))

(define (@mth_bug_fix_concat //i)
  (if (and (= (@st //i) //t_/concat) (> (@size //i) 2))
    (@make //t_/concat
           '()
           (list (@mth_bug_fix_concat
                   (@make //t_/concat '() (butlast-1 (@cs //i))))
                 (last-1 (@cs //i))))
    //i))

(define (@mth_prettify_inverses
         //times
         //invert
         //divide)
  (let ((/top '()) (/bottom '()) (/comp-save /comp))
    (set! /comp '())
    (let ((var-save /comp) (seq-save (@cs (@i))))
      (if (vector? seq-save)
        (set! seq-save (vector-elts seq-save)))
      (let for-in-loop ((for-tmp seq-save))
        (cond ((not (null? for-tmp))
               (set! /comp (car for-tmp))
               (cond ((= (@st /comp) //invert)
                      (set! /bottom
                        (cons (list-ref /comp (+ 1 1)) /bottom)))
                     (#t (set! /top (cons /comp /top))))
               (for-in-loop (cdr for-tmp)))
              (#t #t)))
      (set! /comp var-save))
    (cond ((null? /top)
           (@paste_over
             (@make //invert
                    '()
                    (list (@c_make //times /bottom)))))
          (#t
           (@paste_over
             (@make //divide
                    '()
                    (list (@c_make //times /top)
                          (@c_make //times /bottom))))))
    (set! /comp /comp-save)))

(define (@c_make /type //l)
  (if (= (if (vector? //l)
           (vector-length //l)
           (length //l))
         1)
    (car //l)
    (@make /type '() //l)))

(define (@simplify_bit_ops)
  (let ((/bit_and-save /bit_and)
        (/bit_or-save /bit_or)
        (/bit_xor-save /bit_xor))
    (set! /bit_and (@make_name "bit_and"))
    (set! /bit_or (@make_name "bit_or"))
    (set! /bit_xor (@make_name "bit_xor"))
    (@foreach_expn /foreach-maths-24 0 (@as_type) 0)
    (cond ((null? (@program)) (@new_program (@skips))))
    (set! /bit_and /bit_and-save)
    (set! /bit_or /bit_or-save)
    (set! /bit_xor /bit_xor-save)))

(define (@simplify_bit /type)
  (let ((/comps (@cs (list-ref (@i) (+ 1 2))))
        (//o/k 1)
        (/comp-save /comp)
        (/pars '()))
    (set! /comp '())
    (let ((var-save /comp) (seq-save /comps))
      (if (vector? seq-save)
        (set! seq-save (vector-elts seq-save)))
      (let for-in-loop ((for-tmp seq-save))
        (cond ((not (null? for-tmp))
               (set! /comp (car for-tmp))
               (cond ((= (@st /comp) //t_/number)
                      (set! /pars
                        (cons (@num_to_hex (@v /comp)) /pars)))
                     ((and (= (@st /comp) //t_/string)
                           (@starts_with? (@v /comp) "hex 0x"))
                      (set! /pars
                        (cons (my-string-upcase
                                (let ((s (@v /comp)))
                                  (substring s 6 (string-length s))))
                              /pars)))
                     (#t (set! //o/k 0)))
               (for-in-loop (cdr for-tmp)))
              (#t #t)))
      (set! /comp var-save))
    (cond ((= //o/k 1)
           (let while-loop ()
             (cond ((> (if (vector? /pars)
                         (vector-length /pars)
                         (length /pars))
                       1)
                    (set! /pars
                      (cons (@bit_op
                              /type
                              (let ((name /pars))
                                (if (vector? name)
                                  (vector-ref name (- 1 1))
                                  (list-ref name (- 1 1))))
                              (let ((name /pars))
                                (if (vector? name)
                                  (vector-ref name (- 2 1))
                                  (list-ref name (- 2 1)))))
                            (@final_seg /pars 3)))
                    (while-loop))
                   (#t #t)))
           (cond ((@mth_zeros?
                    (let ((name /pars))
                      (if (vector? name)
                        (vector-ref name (- 1 1))
                        (list-ref name (- 1 1)))))
                  (@paste_over (@make //t_/number 0 '())))
                 (#t
                  (@paste_over
                    (@make //t_/string
                           (string-append
                             "hex 0x"
                             (let ((name /pars))
                               (if (vector? name)
                                 (vector-ref name (- 1 1))
                                 (list-ref name (- 1 1)))))
                           '()))))))
    (set! /comp /comp-save)))

(define (@mth_zeros? /s)
  (or (= (string-length /s) 0)
      (and (equal?
             (let ((f 0)) (substring /s f (+ f 1)))
             "0")
           (@mth_zeros?
             (let ((s /s)) (substring s 1 (string-length s)))))))

(define (@bit_op /type /p1 /p2)
  (let ((//r-save //r)
        (/n-save /n)
        (/i 0)
        (funct-result '()))
    (set! //r "")
    (set! /n
      (max (string-length /p1) (string-length /p2)))
    (let ((var-save /i) (for-step 1) (for-end /n))
      (set! /i (+ (string-length /p1) 1))
      (let for-loop ()
        (cond ((or (and (> 1 0) (<= /i for-end))
                   (and (< 1 0) (>= /i for-end)))
               (set! /p1 (string-append "0" /p1))
               (set! /i (+ /i for-step))
               (for-loop))
              (#t #t)))
      (set! /i var-save))
    (let ((var-save /i) (for-step 1) (for-end /n))
      (set! /i (+ (string-length /p2) 1))
      (let for-loop ()
        (cond ((or (and (> 1 0) (<= /i for-end))
                   (and (< 1 0) (>= /i for-end)))
               (set! /p2 (string-append "0" /p2))
               (set! /i (+ /i for-step))
               (for-loop))
              (#t #t)))
      (set! /i var-save))
    (let ((var-save /i) (for-step 1) (for-end (- /n 1)))
      (set! /i 0)
      (let for-loop ()
        (cond ((or (and (> 1 0) (<= /i for-end))
                   (and (< 1 0) (>= /i for-end)))
               (set! //r
                 (concat
                   //r
                   (gethash
                     //bit_/op
                     (list /type
                           (let ((f /i)) (substring /p1 f (+ f 1)))
                           (let ((f /i)) (substring /p2 f (+ f 1)))))))
               (set! /i (+ /i for-step))
               (for-loop))
              (#t #t)))
      (set! /i var-save))
    (set! funct-result //r)
    (set! //r //r-save)
    (set! /n /n-save)
    funct-result))

(set! //bit_/op (my-make-hash-table 16))

(let ((/bit_and (@make_name "bit_and"))
      (/bit_or (@make_name "bit_or"))
      (/bit_xor (@make_name "bit_xor"))
      (/type '())
      (/p1 0)
      (/p2 0)
      (/p11 0)
      (/p22 0)
      (/r 0)
      (/bit 0)
      (/digits "0123456789ABCDEF"))
  (let ((var-save /type)
        (seq-save (list /bit_and /bit_or /bit_xor)))
    (if (vector? seq-save)
      (set! seq-save (vector-elts seq-save)))
    (let for-in-loop ((for-tmp seq-save))
      (cond ((not (null? for-tmp))
             (set! /type (car for-tmp))
             (let ((var-save /p1) (for-step 1) (for-end 15))
               (set! /p1 0)
               (let for-loop ()
                 (cond ((or (and (> 1 0) (<= /p1 for-end))
                            (and (< 1 0) (>= /p1 for-end)))
                        (let ((var-save /p2) (for-step 1) (for-end 15))
                          (set! /p2 0)
                          (let for-loop ()
                            (cond ((or (and (> 1 0) (<= /p2 for-end))
                                       (and (< 1 0) (>= /p2 for-end)))
                                   (begin
                                     (set! /bit 1)
                                     (set! /r 0)
                                     (set! /p11 /p1)
                                     (set! /p22 /p2)
                                     (let while-loop ()
                                       (cond ((or (> /p11 0) (> /p22 0))
                                              (begin
                                                (cond ((equal? /type /bit_and)
                                                       (cond ((and (= (modulo
                                                                        /p11
                                                                        2)
                                                                      1)
                                                                   (= (modulo
                                                                        /p22
                                                                        2)
                                                                      1))
                                                              (set! /r
                                                                (+ /r /bit)))))
                                                      ((equal? /type /bit_or)
                                                       (cond ((or (= (modulo
                                                                       /p11
                                                                       2)
                                                                     1)
                                                                  (= (modulo
                                                                       /p22
                                                                       2)
                                                                     1))
                                                              (set! /r
                                                                (+ /r /bit)))))
                                                      ((equal? /type /bit_xor)
                                                       (cond ((or (and (= (modulo
                                                                            /p11
                                                                            2)
                                                                          0)
                                                                       (= (modulo
                                                                            /p22
                                                                            2)
                                                                          1))
                                                                  (and (= (modulo
                                                                            /p11
                                                                            2)
                                                                          1)
                                                                       (= (modulo
                                                                            /p22
                                                                            2)
                                                                          0)))
                                                              (set! /r
                                                                (+ /r /bit))))))
                                                (set! /p11 (quotient /p11 2))
                                                (set! /p22 (quotient /p22 2))
                                                (set! /bit (* /bit 2)))
                                              (while-loop))
                                             (#t #t)))
                                     (puthash
                                       //bit_/op
                                       (list /type
                                             (let ((f /p1))
                                               (substring /digits f (+ f 1)))
                                             (let ((f /p2))
                                               (substring /digits f (+ f 1))))
                                       (let ((f /r))
                                         (substring /digits f (+ f 1)))))
                                   (set! /p2 (+ /p2 for-step))
                                   (for-loop))
                                  (#t #t)))
                          (set! /p2 var-save))
                        (set! /p1 (+ /p1 for-step))
                        (for-loop))
                       (#t #t)))
               (set! /p1 var-save))
             (for-in-loop (cdr for-tmp)))
            (#t #t)))
    (set! /type var-save)))

(define (@mth_expensive //budget-par)
  (let ((//budget-save //budget))
    (set! //budget //budget-par)
    (let ((//orig '())
          (//b1 '())
          (//b2 '())
          (/comp-save /comp)
          (/not_comp '())
          (//r-save //r))
      (set! /comp '())
      (set! //r '())
      (set! /fl_flag2 0)
      (let while-loop ()
        (cond ((= /fl_flag2 0)
               (cond ((<= //budget 10) (set! /fl_flag2 1))
                     (#t
                      (set! //orig (@i))
                      (cond ((and #f
                                  (or (= (@st (@i)) //t_/and)
                                      (= (@st (@i)) //t_/or)))
                             (begin
                               (display "@Mth_Expensive")
                               (newline)
                               (force-output))
                             (@pp_item (@i) 80 "")
                             (begin (display "") (newline) (force-output))))
                      (cond ((= (@st (@i)) //t_/and)
                             (set! //b1 '())
                             (set! //b2 (cdr (@cs (@i))))
                             (set! /comp (list-ref (@i) (+ 1 1)))
                             (set! /fl_flag1 0)
                             (let while-loop ()
                               (cond ((= /fl_flag1 0)
                                      (begin
                                        (cond ((or (and (member
                                                          (@st /comp)
                                                          //mth_/rels)
                                                        (or (= (@st (list-ref
                                                                      /comp
                                                                      (+ 1 1)))
                                                               //t_/number)
                                                            (= (@st (list-ref
                                                                      /comp
                                                                      (+ 1 2)))
                                                               //t_/number))
                                                        (or (or (= (@st (list-ref
                                                                          /comp
                                                                          (+ 1
                                                                             1)))
                                                                   //t_/variable)
                                                                (= (@st (list-ref
                                                                          /comp
                                                                          (+ 1
                                                                             1)))
                                                                   //t_/struct))
                                                            (or (= (@st (list-ref
                                                                          /comp
                                                                          (+ 1
                                                                             2)))
                                                                   //t_/variable)
                                                                (= (@st (list-ref
                                                                          /comp
                                                                          (+ 1
                                                                             2)))
                                                                   //t_/struct))))
                                                   (= (@st /comp)
                                                      //t_/b/funct_/call))
                                               (cond ((= (if (vector? //b1)
                                                           (vector-length //b1)
                                                           (length //b1))
                                                         1)
                                                      (set! //r
                                                        (@mth_simplify_using
                                                          (car //b1)
                                                          /comp
                                                          (- //budget 1)))
                                                      (cond ((< (@total_size
                                                                  //r)
                                                                (@total_size
                                                                  (car //b1)))
                                                             (@paste_over
                                                               (@make //t_/and
                                                                      '()
                                                                      (cons //r
                                                                            (cons /comp
                                                                                  //b2))))
                                                             (set! /fl_flag1 1))
                                                            (#t
                                                             (set! /fl_flag1
                                                               0))))
                                                     ((> (if (vector? //b1)
                                                           (vector-length //b1)
                                                           (length //b1))
                                                         1)
                                                      (set! //r
                                                        (@mth_simplify_using
                                                          (@make //t_/and
                                                                 '()
                                                                 //b1)
                                                          /comp
                                                          (- //budget 1)))
                                                      (cond ((< (@total_size
                                                                  //r)
                                                                (@total_size
                                                                  (@make //t_/and
                                                                         '()
                                                                         //b1)))
                                                             (@paste_over
                                                               (@make //t_/and
                                                                      '()
                                                                      (cons //r
                                                                            (cons /comp
                                                                                  //b2))))
                                                             (set! /fl_flag1 1))
                                                            (#t
                                                             (set! /fl_flag1
                                                               0))))
                                                     (#t (set! /fl_flag1 0)))
                                               (cond ((= /fl_flag1 0)
                                                      (cond ((= (if (vector?
                                                                      //b2)
                                                                  (vector-length
                                                                    //b2)
                                                                  (length //b2))
                                                                1)
                                                             (set! //r
                                                               (@mth_simplify_using
                                                                 (car //b2)
                                                                 /comp
                                                                 (- //budget
                                                                    1)))
                                                             (cond ((< (@total_size
                                                                         //r)
                                                                       (@total_size
                                                                         (car //b2)))
                                                                    (@paste_over
                                                                      (@make //t_/and
                                                                             '()
                                                                             (cons /comp
                                                                                   (cons //r
                                                                                         //b1))))
                                                                    (set! /fl_flag1
                                                                      1))
                                                                   (#t
                                                                    (set! /fl_flag1
                                                                      0))))
                                                            ((> (if (vector?
                                                                      //b2)
                                                                  (vector-length
                                                                    //b2)
                                                                  (length //b2))
                                                                1)
                                                             (set! //r
                                                               (@mth_simplify_using
                                                                 (@make //t_/and
                                                                        '()
                                                                        //b2)
                                                                 /comp
                                                                 (- //budget
                                                                    1)))
                                                             (cond ((< (@total_size
                                                                         //r)
                                                                       (@total_size
                                                                         (@make //t_/and
                                                                                '()
                                                                                //b2)))
                                                                    (@paste_over
                                                                      (@make //t_/and
                                                                             '()
                                                                             (cons /comp
                                                                                   (cons //r
                                                                                         //b1))))
                                                                    (set! /fl_flag1
                                                                      1))
                                                                   (#t
                                                                    (set! /fl_flag1
                                                                      0))))
                                                            (#t
                                                             (set! /fl_flag1
                                                               0))))))
                                              (#t (set! /fl_flag1 0)))
                                        (cond ((= /fl_flag1 0)
                                               (cond ((null? //b2)
                                                      (set! /fl_flag1 1))
                                                     (#t
                                                      (set! //b1
                                                        (cons /comp //b1))
                                                      (set! /comp (car //b2))
                                                      (set! //b2 (cdr //b2))
                                                      (set! /fl_flag1 0))))))
                                      (while-loop))
                                     (#t #t))))
                            ((= (@st (@i)) //t_/or)
                             (set! //b1 '())
                             (set! //b2 (cdr (@cs (@i))))
                             (set! /comp (list-ref (@i) (+ 1 1)))
                             (set! /not_comp (@not (list-ref (@i) (+ 1 1))))
                             (set! /fl_flag1 0)
                             (let while-loop ()
                               (cond ((= /fl_flag1 0)
                                      (begin
                                        (cond ((or (and (member
                                                          (@st /comp)
                                                          //mth_/rels)
                                                        (or (= (@st (list-ref
                                                                      /comp
                                                                      (+ 1 1)))
                                                               //t_/number)
                                                            (= (@st (list-ref
                                                                      /comp
                                                                      (+ 1 2)))
                                                               //t_/number))
                                                        (or (or (= (@st (list-ref
                                                                          /comp
                                                                          (+ 1
                                                                             1)))
                                                                   //t_/variable)
                                                                (= (@st (list-ref
                                                                          /comp
                                                                          (+ 1
                                                                             1)))
                                                                   //t_/struct))
                                                            (or (= (@st (list-ref
                                                                          /comp
                                                                          (+ 1
                                                                             2)))
                                                                   //t_/variable)
                                                                (= (@st (list-ref
                                                                          /comp
                                                                          (+ 1
                                                                             2)))
                                                                   //t_/struct))))
                                                   (= (@st /comp)
                                                      //t_/b/funct_/call))
                                               (cond ((= (if (vector? //b1)
                                                           (vector-length //b1)
                                                           (length //b1))
                                                         1)
                                                      (set! //r
                                                        (@mth_simplify_using
                                                          (car //b1)
                                                          /not_comp
                                                          (- //budget 1)))
                                                      (cond ((< (@total_size
                                                                  //r)
                                                                (@total_size
                                                                  (car //b1)))
                                                             (@paste_over
                                                               (@make //t_/or
                                                                      '()
                                                                      (cons //r
                                                                            (cons /comp
                                                                                  //b2))))
                                                             (set! /fl_flag1 1))
                                                            (#t
                                                             (set! /fl_flag1
                                                               0))))
                                                     ((> (if (vector? //b1)
                                                           (vector-length //b1)
                                                           (length //b1))
                                                         1)
                                                      (set! //r
                                                        (@mth_simplify_using
                                                          (@make //t_/or
                                                                 '()
                                                                 //b1)
                                                          /not_comp
                                                          (- //budget 1)))
                                                      (cond ((< (@total_size
                                                                  //r)
                                                                (@total_size
                                                                  (@make //t_/or
                                                                         '()
                                                                         //b1)))
                                                             (@paste_over
                                                               (@make //t_/or
                                                                      '()
                                                                      (cons //r
                                                                            (cons /comp
                                                                                  //b2))))
                                                             (set! /fl_flag1 1))
                                                            (#t
                                                             (set! /fl_flag1
                                                               0))))
                                                     (#t (set! /fl_flag1 0)))
                                               (cond ((= /fl_flag1 0)
                                                      (cond ((= (if (vector?
                                                                      //b2)
                                                                  (vector-length
                                                                    //b2)
                                                                  (length //b2))
                                                                1)
                                                             (set! //r
                                                               (@mth_simplify_using
                                                                 (car //b2)
                                                                 /not_comp
                                                                 (- //budget
                                                                    1)))
                                                             (cond ((< (@total_size
                                                                         //r)
                                                                       (@total_size
                                                                         (car //b2)))
                                                                    (@paste_over
                                                                      (@make //t_/or
                                                                             '()
                                                                             (cons /comp
                                                                                   (cons //r
                                                                                         //b1))))
                                                                    (set! /fl_flag1
                                                                      1))
                                                                   (#t
                                                                    (set! /fl_flag1
                                                                      0))))
                                                            ((> (if (vector?
                                                                      //b2)
                                                                  (vector-length
                                                                    //b2)
                                                                  (length //b2))
                                                                1)
                                                             (set! //r
                                                               (@mth_simplify_using
                                                                 (@make //t_/or
                                                                        '()
                                                                        //b2)
                                                                 /not_comp
                                                                 (- //budget
                                                                    1)))
                                                             (cond ((< (@total_size
                                                                         //r)
                                                                       (@total_size
                                                                         (@make //t_/or
                                                                                '()
                                                                                //b2)))
                                                                    (@paste_over
                                                                      (@make //t_/or
                                                                             '()
                                                                             (cons /comp
                                                                                   (cons //r
                                                                                         //b1))))
                                                                    (set! /fl_flag1
                                                                      1))
                                                                   (#t
                                                                    (set! /fl_flag1
                                                                      0))))
                                                            (#t
                                                             (set! /fl_flag1
                                                               0))))))
                                              (#t (set! /fl_flag1 0)))
                                        (cond ((= /fl_flag1 0)
                                               (cond ((null? //b2)
                                                      (set! /fl_flag1 1))
                                                     (#t
                                                      (set! //b1
                                                        (cons /comp //b1))
                                                      (set! /comp (car //b2))
                                                      (set! /not_comp
                                                        (@not /comp))
                                                      (set! //b2 (cdr //b2))
                                                      (set! /fl_flag1 0))))))
                                      (while-loop))
                                     (#t #t)))))
                      (cond ((@equal? //orig (@i)) (set! /fl_flag2 1))
                            (#t
                             (set! //budget (- //budget 1))
                             (set! /fl_flag2 0)))))
               (while-loop))
              (#t #t)))
      (set! /comp /comp-save)
      (set! //r //r-save))
    (set! //budget //budget-save)))

(define (@simplify_using //a //b-par //budget-par)
  (let ((//budget-save //budget)
        (//b-save //b)
        (//r-save //r)
        (funct-result '()))
    (set! //budget //budget-par)
    (set! //b //b-par)
    (set! //r '())
    (set! //r (@mth_simplify_using //a //b //budget))
    (cond ((< (@total_size //r) (@total_size //a))
           (set! //r (@simplify //r (quotient //budget 2))))
          (#t (set! //r //a)))
    (set! funct-result //r)
    (set! //budget //budget-save)
    (set! //b //b-save)
    (set! //r //r-save)
    funct-result))

(define (@mth_simplify_using //a //b-par //budget-par)
  (let ((//budget-save //budget)
        (//b-save //b)
        (//r-save //r)
        (/v-save /v)
        (/e '())
        (/not_/b-save /not_/b)
        (funct-result '()))
    (set! //budget //budget-par)
    (set! //b //b-par)
    (set! //r '())
    (set! /v '())
    (set! /not_/b '())
    (cond ((or (<= //budget 10)
               (null? (@set_intersect (@used //a) (@used //b))))
           (set! //r //a)))
    (cond (#f
           (begin
             (display "Simplify: ")
             (newline)
             (force-output))
           (@pp_item //a 80 "")
           (begin
             (display "Using: ")
             (newline)
             (force-output))
           (@pp_item //b 80 "")))
    (cond ((and (null? //r)
                (= (@st //b) //t_/equal)
                (not (null? (@set_intersect
                              (@used //a)
                              (@used (list-ref //b (+ 1 1)))))))
           (set! //r
             (@mth_replace
               (list-ref //b (+ 1 1))
               (list-ref //b (+ 1 2))
               //a))
           (cond ((>= (@total_size //r) (@total_size //a))
                  (set! //r '())))))
    (cond ((and (null? //r)
                (= (@st //b) //t_/equal)
                (not (null? (@set_intersect
                              (@used //a)
                              (@used (list-ref //b (+ 1 2)))))))
           (set! //r
             (@mth_replace
               (list-ref //b (+ 1 2))
               (list-ref //b (+ 1 1))
               //a))
           (cond ((>= (@total_size //r) (@total_size //a))
                  (set! //r '())))))
    (cond ((null? //r)
           (set! /not_/b (@not //b))
           (@edit)
           (@new_program //a)
           (@foreach_cond /foreach-maths-25 0 (@as_type) 0)
           (cond ((null? (@program)) (@new_program (@skips))))
           (cond ((<= (@total_size (@program)) (@total_size //a))
                  (set! //r (@program))))
           (@undo_edit)))
    (cond ((null? //r) (set! //r //a)))
    (cond (#f
           (begin
             (display "Result: ")
             (newline)
             (force-output))
           (@pp_item //r 80 "")
           (begin (display "") (newline) (force-output))))
    (set! funct-result //r)
    (set! //budget //budget-save)
    (set! //b //b-save)
    (set! //r //r-save)
    (set! /v /v-save)
    (set! /not_/b /not_/b-save)
    funct-result))

(define (@mth_replace /e1 /e2 //b-par)
  (let ((//b-save //b)
        (//r-save //r)
        (funct-result '()))
    (set! //b //b-par)
    (set! //r '())
    (cond ((@equal? //b /e1) (set! //r /e2))
          ((> (@total_size //b) (@total_size /e1))
           (let ((/new-save /new) (/e '()))
             (set! /new '())
             (cond ((= (@st //b) //t_/aref)
                    (set! /new
                      (list (@mth_replace /e1 /e2 (list-ref //b (+ 1 2)))
                            (list-ref //b (+ 1 1)))))
                   (#t
                    (let ((var-save /comp) (seq-save (@cs //b)))
                      (if (vector? seq-save)
                        (set! seq-save (vector-elts seq-save)))
                      (let for-in-loop ((for-tmp seq-save))
                        (cond ((not (null? for-tmp))
                               (set! /comp (car for-tmp))
                               (set! /new
                                 (cons (@mth_replace /e1 /e2 /comp) /new))
                               (for-in-loop (cdr for-tmp)))
                              (#t #t)))
                      (set! /comp var-save))))
             (set! //r (@make (@st //b) '() (reverse /new)))
             (cond ((@equal? //r //b) (set! //r //b))
                   (#t (set! //r (@simplify //r 10))))
             (set! /new /new-save)))
          (#t (set! //r //b)))
    (set! funct-result //r)
    (set! //b //b-save)
    (set! //r //r-save)
    funct-result))

(define (@mth_replace_orig /e1 /e2 //b-par)
  (let ((//b-save //b)
        (//r-save //r)
        (funct-result '()))
    (set! //b //b-par)
    (set! //r '())
    (cond ((@equal? //b /e1) (set! //r /e2))
          ((> (@total_size //b) (@total_size /e1))
           (let ((/new-save /new) (/e '()))
             (set! /new '())
             (let ((var-save /comp) (seq-save (@cs //b)))
               (if (vector? seq-save)
                 (set! seq-save (vector-elts seq-save)))
               (let for-in-loop ((for-tmp seq-save))
                 (cond ((not (null? for-tmp))
                        (set! /comp (car for-tmp))
                        (set! /new
                          (cons (@mth_replace /e1 /e2 /comp) /new))
                        (for-in-loop (cdr for-tmp)))
                       (#t #t)))
               (set! /comp var-save))
             (set! //r (@make (@st //b) '() (reverse /new)))
             (cond ((@equal? //r //b) (set! //r //b))
                   (#t (set! //r (@simplify //r 10))))
             (set! /new /new-save)))
          (#t (set! //r //b)))
    (set! funct-result //r)
    (set! //b //b-save)
    (set! //r //r-save)
    funct-result))

(define (@mth_quantifiers //budget-par)
  (let ((//budget-save //budget))
    (set! //budget //budget-par)
    (let ((/vars-save /vars) (/new-save /new) (/rest '()))
      (set! /vars (@variables (list-ref (@i) (+ 1 1))))
      (set! /new '())
      (cond ((null? (@set_intersect
                      /vars
                      (@used (list-ref (@i) (+ 1 2)))))
             (@paste_over (list-ref (@i) (+ 1 2))))
            ((or (and (= (@st (@i)) //t_/exists)
                      (= (@st (list-ref (@i) (+ 1 2))) //t_/or))
                 (and (= (@st (@i)) //t_/forall)
                      (= (@st (list-ref (@i) (+ 1 2))) //t_/and)))
             (let ((var-save /comp)
                   (seq-save (@cs (list-ref (@i) (+ 1 2)))))
               (if (vector? seq-save)
                 (set! seq-save (vector-elts seq-save)))
               (let for-in-loop ((for-tmp seq-save))
                 (cond ((not (null? for-tmp))
                        (set! /comp (car for-tmp))
                        (cond ((null? (@set_intersect /vars (@used /comp)))
                               (set! /new (cons /comp /new)))
                              (#t
                               (set! /new
                                 (cons (@make (@st (@i))
                                              '()
                                              (list (list-ref (@i) (+ 1 1))
                                                    /comp))
                                       /new))))
                        (for-in-loop (cdr for-tmp)))
                       (#t #t)))
               (set! /comp var-save))
             (@paste_over
               (@make (@st (list-ref (@i) (+ 1 2)))
                      '()
                      (reverse /new))))
            ((or (= (@st (list-ref (@i) (+ 1 2))) //t_/or)
                 (= (@st (list-ref (@i) (+ 1 2))) //t_/and))
             (let ((var-save /comp)
                   (seq-save (@cs (list-ref (@i) (+ 1 2)))))
               (if (vector? seq-save)
                 (set! seq-save (vector-elts seq-save)))
               (let for-in-loop ((for-tmp seq-save))
                 (cond ((not (null? for-tmp))
                        (set! /comp (car for-tmp))
                        (cond ((not (null? (@set_intersect
                                             /vars
                                             (@used /comp))))
                               (set! /new (cons /comp /new)))
                              (#t (set! /rest (cons /comp /rest))))
                        (for-in-loop (cdr for-tmp)))
                       (#t #t)))
               (set! /comp var-save))
             (cond ((not (null? /rest))
                    (cond ((> (if (vector? /new)
                                (vector-length /new)
                                (length /new))
                              1)
                           (set! /new
                             (@make (@st (list-ref (@i) (+ 1 2)))
                                    '()
                                    (reverse /new))))
                          (#t (set! /new (car /new))))
                    (set! /new
                      (@make (@st (@i))
                             '()
                             (list (list-ref (@i) (+ 1 1)) /new)))
                    (@paste_over
                      (@make (@st (list-ref (@i) (+ 1 2)))
                             '()
                             (cons /new (reverse /rest)))))
                   (#t (@mth_quantifiers_sub //budget))))
            (#t (@mth_quantifiers_sub //budget)))
      (set! /vars /vars-save)
      (set! /new /new-save))
    (set! //budget //budget-save)))

(define (@mth_quantifiers_sub //budget-par)
  (let ((//budget-save //budget))
    (set! //budget //budget-par)
    (let ((/vars-save /vars)
          (/replace-save /replace)
          (/sub 0)
          (/rel-save /rel))
      (set! /vars (@variables (list-ref (@i) (+ 1 1))))
      (set! /replace (my-make-hash-table 16))
      (set! /rel 0)
      (cond ((= (@st (@i)) //t_/forall)
             (set! /sub //t_/or)
             (set! /rel //t_/not_/equal))
            (#t (set! /sub //t_/and) (set! /rel //t_/equal)))
      (@down_to 2)
      (cond ((= (@st (@i)) /sub)
             (let ((var-save /comp) (seq-save (@cs (@i))))
               (if (vector? seq-save)
                 (set! seq-save (vector-elts seq-save)))
               (let for-in-loop ((for-tmp seq-save))
                 (cond ((not (null? for-tmp))
                        (set! /comp (car for-tmp))
                        (cond ((and (= (@st /comp) /rel)
                                    (= (@st (list-ref /comp (+ 1 1)))
                                       //t_/variable)
                                    (member
                                      (@v (list-ref /comp (+ 1 1)))
                                      /vars))
                               (puthash
                                 /replace
                                 (@v (list-ref /comp (+ 1 1)))
                                 (list-ref /comp (+ 1 2))))
                              ((and (= (@st /comp) /rel)
                                    (= (@st (list-ref /comp (+ 1 2)))
                                       //t_/variable)
                                    (member
                                      (@v (list-ref /comp (+ 1 2)))
                                      /vars))
                               (puthash
                                 /replace
                                 (@v (list-ref /comp (+ 1 2)))
                                 (list-ref /comp (+ 1 1)))))
                        (for-in-loop (cdr for-tmp)))
                       (#t #t)))
               (set! /comp var-save))
             (@foreach_global_var
               /foreach-maths-26
               0
               (@as_type)
               0)
             (cond ((null? (@program)) (@new_program (@skips))))))
      (@up)
      (cond ((= (@st (@i)) //t_/exists)
             (@down_to 2)
             (let ((/count-save /count))
               (set! /count 0)
               (let ((var-save /v) (seq-save /vars))
                 (if (vector? seq-save)
                   (set! seq-save (vector-elts seq-save)))
                 (let for-in-loop ((for-tmp seq-save))
                   (cond ((not (null? for-tmp))
                          (set! /v (car for-tmp))
                          (begin
                            (set! /count 0)
                            (@foreach_global_var
                              /foreach-maths-27
                              0
                              (@as_type)
                              0)
                            (cond ((null? (@program)) (@new_program (@skips))))
                            (cond ((= /count 1)
                                   (let ((/var-save /var))
                                     (set! /var (@make //t_/variable /v '()))
                                     (@foreach_cond
                                       /foreach-maths-28
                                       0
                                       (@as_type)
                                       0)
                                     (cond ((null? (@program))
                                            (@new_program (@skips))))
                                     (set! /var /var-save)))))
                          (for-in-loop (cdr for-tmp)))
                         (#t #t)))
                 (set! /v var-save))
               (set! /count /count-save))
             (@up)))
      (cond ((not (null? (@set_difference
                           /vars
                           (@used (list-ref (@i) (+ 1 2))))))
             (set! /vars
               (@set_intersect
                 /vars
                 (@used (list-ref (@i) (+ 1 2)))))
             (cond ((null? /vars)
                    (@paste_over (list-ref (@i) (+ 1 2))))
                   (#t
                    (let ((/new-save /new))
                      (set! /new '())
                      (let ((var-save /v) (seq-save /vars))
                        (if (vector? seq-save)
                          (set! seq-save (vector-elts seq-save)))
                        (let for-in-loop ((for-tmp seq-save))
                          (cond ((not (null? for-tmp))
                                 (set! /v (car for-tmp))
                                 (set! /new
                                   (cons (@make //t_/var_/lvalue /v '()) /new))
                                 (for-in-loop (cdr for-tmp)))
                                (#t #t)))
                        (set! /v var-save))
                      (@down)
                      (@paste_over
                        (@make //t_/lvalues '() (reverse /new)))
                      (@up)
                      (set! /new /new-save))))))
      (set! /vars /vars-save)
      (set! /replace /replace-save)
      (set! /rel /rel-save))
    (set! //budget //budget-save)))

(define (@simplify_bfunct_calls //budget-par)
  (let ((//budget-save //budget))
    (set! //budget //budget-par)
    (let ((/calls-save /calls))
      (set! /calls '())
      (@foreach_cond /foreach-maths-29 0 (@as_type) 0)
      (cond ((null? (@program)) (@new_program (@skips))))
      (cond ((not (null? /calls))
             (let ((/new1 '()) (/new2 '()))
               (let ((var-save /call) (seq-save /calls))
                 (if (vector? seq-save)
                   (set! seq-save (vector-elts seq-save)))
                 (let for-in-loop ((for-tmp seq-save))
                   (cond ((not (null? for-tmp))
                          (set! /call (car for-tmp))
                          (begin
                            (set! /new1
                              (@replace_condition (@i) /call //mth_/true 5))
                            (set! /new2
                              (@replace_condition (@i) /call //mth_/false 5))
                            (cond ((and (@equal? /new1 /new2)
                                        (< (@total_size /new1)
                                           (@total_size (@i))))
                                   (@paste_over /new1))
                                  ((< (+ (+ (+ (@total_size /new1)
                                               (@total_size /new2))
                                            (* 2 (@total_size /call)))
                                         4)
                                      (@total_size (@i)))
                                   (@paste_over
                                     (@make 311
                                            '()
                                            (list (@make 310
                                                         '()
                                                         (list /call /new1))
                                                  (@make 310
                                                         '()
                                                         (list (@make 312
                                                                      '()
                                                                      (list /call))
                                                               /new2))))))))
                          (for-in-loop (cdr for-tmp)))
                         (#t #t)))
                 (set! /call var-save)))))
      (set! /calls /calls-save))
    (set! //budget //budget-save)))

(define (@replace_condition
         //i-par
         /old-par
         /new-par
         //budget-par)
  (let ((//budget-save //budget)
        (/new-save /new)
        (/old-save /old)
        (//i-save //i)
        (//r-save //r)
        (funct-result '()))
    (set! //budget //budget-par)
    (set! /new /new-par)
    (set! /old /old-par)
    (set! //i //i-par)
    (set! //r '())
    (@edit)
    (@new_program //i)
    (@foreach_cond /foreach-maths-30 0 (@as_type) 0)
    (cond ((null? (@program)) (@new_program (@skips))))
    (set! //r (@simplify (@program) //budget))
    (@undo_edit)
    (set! funct-result //r)
    (set! //budget //budget-save)
    (set! /new /new-save)
    (set! /old /old-save)
    (set! //i //i-save)
    (set! //r //r-save)
    funct-result))

#t

